/*
 Navicat MySQL Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 50720
 Source Host           : localhost:3306
 Source Schema         : myblog

 Target Server Type    : MySQL
 Target Server Version : 50720
 File Encoding         : 65001

 Date: 06/06/2018 15:57:11
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_attach
-- ----------------------------
DROP TABLE IF EXISTS `t_attach`;
CREATE TABLE `t_attach`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `fname` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '文件名称',
  `ftype` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '' COMMENT '文件类型',
  `fkey` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '文件路径',
  `author_id` int(10) DEFAULT NULL COMMENT '上传用户id',
  `created` int(10) NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '文件表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_attach
-- ----------------------------
INSERT INTO `t_attach` VALUES (1, '密码.txt', 'file', '/upload/2018/05/p3j91c6vlch5prm6vmkfatoage.txt', 1, 1525782445);
INSERT INTO `t_attach` VALUES (4, '哈哈.rar', 'file', '/upload/2018/05/uhife2m61mipvqqv8pl1h5gi88.rar', 1, 1527687877);
INSERT INTO `t_attach` VALUES (5, 'vamavrug1ihfkp87tr018lulme.jpg', 'image', '/upload/2018/05/p665iib3m2hverp8l839dd97er.jpg', 1, 1527694924);

-- ----------------------------
-- Table structure for t_comments
-- ----------------------------
DROP TABLE IF EXISTS `t_comments`;
CREATE TABLE `t_comments`  (
  `coid` int(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'comment表主键',
  `cid` int(10) UNSIGNED DEFAULT 0 COMMENT 'post表主键,关联字段',
  `created` int(10) UNSIGNED DEFAULT 0 COMMENT '创建时间',
  `author` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '评论作者',
  `author_id` int(10) UNSIGNED DEFAULT 0 COMMENT '评论所属用户id',
  `owner_id` int(10) UNSIGNED DEFAULT 0 COMMENT '评论所属内容作者id',
  `mail` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '评论者邮件',
  `url` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '评论者网址',
  `ip` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '评论者ip地址',
  `agent` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '评论者客户端',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT '评论内容',
  `type` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT 'comment' COMMENT '评论类型',
  `status` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT 'approved' COMMENT '评论状态',
  `parent` int(10) UNSIGNED DEFAULT 0 COMMENT '父级评论',
  PRIMARY KEY (`coid`) USING BTREE,
  INDEX `cid`(`cid`) USING BTREE,
  INDEX `created`(`created`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '评论表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comments
-- ----------------------------
INSERT INTO `t_comments` VALUES (1, 6, 1497672195, 'tzs', 0, 1, '101011@gmail.com', 'http://juejin.im', '0:0:0:0:0:0:0:1', NULL, '棒棒哒，厉害了', 'comment', 'approved', 0);
INSERT INTO `t_comments` VALUES (2, 6, 1497672339, 'tzs', 0, 1, '101011@gmail.com', 'http://juejin.im', '0:0:0:0:0:0:0:1', NULL, '再次评论，看看效果', 'comment', 'approved', 0);
INSERT INTO `t_comments` VALUES (3, 5, 1497676424, 'tzs', 0, 1, '101011@gmail.com', 'http://juejin.im', '0:0:0:0:0:0:0:1', NULL, 'vswfwfwfw', 'comment', 'approved', 0);
INSERT INTO `t_comments` VALUES (4, 7, 1525399789, '11', 0, 1, '1341947277@qq.com', '', '0:0:0:0:0:0:0:1', NULL, '哈哈厉害了', 'comment', 'approved', 0);
INSERT INTO `t_comments` VALUES (5, 6, 1525689453, 'gg', 0, 1, '', '', '0:0:0:0:0:0:0:1', NULL, '66666', 'comment', 'approved', 0);
INSERT INTO `t_comments` VALUES (6, 1, 1526624381, '热心网友', 0, 1, '', '', '0:0:0:0:0:0:0:1', NULL, 'dffffff', 'comment', 'approved', 0);

-- ----------------------------
-- Table structure for t_contents
-- ----------------------------
DROP TABLE IF EXISTS `t_contents`;
CREATE TABLE `t_contents`  (
  `cid` int(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '文章表主键',
  `title` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '内容标题',
  `slug` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '内容缩略名',
  `created` int(10) UNSIGNED DEFAULT 0 COMMENT '创建时间',
  `modified` int(10) UNSIGNED DEFAULT 0 COMMENT '修改时间',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT '内容文字',
  `author_id` int(10) UNSIGNED DEFAULT 0 COMMENT '内容所属用户id',
  `type` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT 'post' COMMENT '内容类别',
  `status` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT 'publish' COMMENT '内容状态',
  `tags` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '标签列表',
  `categories` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '分类列表',
  `hits` int(10) UNSIGNED DEFAULT 0 COMMENT '点击次数',
  `comments_num` int(10) UNSIGNED DEFAULT 0 COMMENT '内容所属评论数',
  `allow_comment` tinyint(1) DEFAULT 1 COMMENT '是否允许评论1：允许 2：关闭',
  `allow_ping` tinyint(1) DEFAULT 1 COMMENT '是否允许ping 1：是 2：否',
  `allow_feed` tinyint(1) DEFAULT 1 COMMENT '允许出现在聚合中 1：是 2：否',
  PRIMARY KEY (`cid`) USING BTREE,
  UNIQUE INDEX `slug`(`slug`) USING BTREE,
  INDEX `created`(`created`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 18 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '文章表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_contents
-- ----------------------------
INSERT INTO `t_contents` VALUES (1, '关于', 'about', 1522766086, 1527687588, '## Hello World\r\n\r\n这是我的关于页面\r\n\r\n## 我的社交信息\r\n\r\n- [使用hexo+Github搭建的博客][1]\r\n\r\n- [我的知乎](https://www.zhihu.com/people/gao-xing-68-15/activities)\r\n\r\n- [我的Github](https://github.com/gaohanghang)\r\n\r\n  [1]: http://ghang.top\r\n\r\n## 还有自己写的小项目\r\n\r\n- [项目服务器](http://gaohang.xyz)\r\n\r\n## 个人技能\r\n\r\n- 熟悉JAVA\r\n- 熟练使用IntelliJ IDEA开发工具\r\n- 熟悉JavaWeb的开发，掌握Spring，SpringMVC，Mybatis等开源框架\r\n- 熟悉Spring Boot的使用\r\n- 熟悉MySQL数据库\r\n- 熟悉tomcat应用服务器的使用\r\n- 掌握Linux的基本命令\r\n- 了解Nginx的使用', 1, 'page', 'publish', NULL, NULL, 160, 1, 1, 1, 1);
INSERT INTO `t_contents` VALUES (3, 'Hello World', 'Hello-World', 1522766086, 1527518318, '# Hello World\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180413/4acb5e5f5a.jpg)', 1, 'post', 'publish', '', '默认分类', 90, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (4, 'MyBatis批量增删改查操作', 'HashMap-HashTable', 1523370886, 1527996054, '> 转载自 [MyBatis批量增删改查操作](http://blog.csdn.net/mahoking/article/details/46811865)\r\n\r\n## 1. 批量增加操作步骤\r\n\r\n- 在接口UserMapper中添加批量增加方法。\r\n\r\n```java\r\n/** \r\n    * 批量增加操作 \r\n    * @param users \r\n    */  \r\n   public void batchInsertUsers(List<User> users);  \r\n```\r\n\r\n- 在User.xml中添加批量增加操作的配置。\r\n\r\n```java\r\n<!-- 批量增加操作 -->  \r\n    <insert id=\"batchInsertUsers\" parameterType=\"java.util.List\">  \r\n        insert into mhc_user(userName,password) values  \r\n        <foreach collection=\"list\" item=\"item\" index=\"index\" separator=\",\">  \r\n            (#{item.userName},#{item.password})  \r\n        </foreach>  \r\n    </insert> \r\n```\r\n\r\n​	由于批量增加的方法中参数为List，所以parameterType的值为java.util.List。\r\n\r\n- 创建批量操作的工具类BatchDataUtils，编写批量增加方法。\r\n\r\n```java\r\n/** \r\n     * 批量增加操作 \r\n     * @param users \r\n     */  \r\n    public static void batchInsertUsers(List<User> users){  \r\n          \r\n        SqlSessionFactory ssf = MyBatisUtil.getSqlSessionFactory();  \r\n        SqlSession session = ssf.openSession();  \r\n          \r\n        try {  \r\n            UserMapper userMapper = session.getMapper(UserMapper.class);  \r\n            userMapper.batchInsertUsers(users);  \r\n            session.commit();  \r\n        } catch (Exception e) {  \r\n            e.printStackTrace();  \r\n        } finally {  \r\n            MyBatisUtil.closeSession(session);  \r\n        }  \r\n    }  \r\n```\r\n\r\n## 2. 批量删除操作步骤\r\n\r\n- 在接口UserMapper中添加删除增加方法。\r\n\r\n```java\r\n/** \r\n     * 批量删除操作 \r\n     * @param ids \r\n     */  \r\n    public void batchDeleteUsers(List ids);  \r\n```\r\n\r\n- 在User.xml中添加批量增加操作的配置。\r\n\r\n```java\r\n<!-- 批量删除操作 -->  \r\n    <delete id=\"batchDeleteUsers\" parameterType=\"java.util.List\">  \r\n        delete from mhc_user where id in  \r\n        <foreach collection=\"list\" index=\"index\" item=\"item\" open=\"(\" close=\")\" separator=\",\">  \r\n            #{item}  \r\n        </foreach>  \r\n    </delete>  \r\n```\r\n\r\n​	由于批量删除的方法中参数为List，所以parameterType的值为java.util.List。\r\n\r\n- 在批量操作的工具类BatchDataUtils中编写批量删除方法。\r\n\r\n```java\r\n/** \r\n     * 批量删除操作 \r\n     * @param ids \r\n     */  \r\n    public static void batchDeleteUsers(List ids){  \r\n        SqlSessionFactory ssf = MyBatisUtil.getSqlSessionFactory();  \r\n        SqlSession session = ssf.openSession();  \r\n          \r\n        try {  \r\n            UserMapper userMapper = session.getMapper(UserMapper.class);  \r\n            userMapper.batchDeleteUsers(ids);  \r\n            session.commit();  \r\n        } catch (Exception e) {  \r\n            e.printStackTrace();  \r\n        } finally {  \r\n            MyBatisUtil.closeSession(session);  \r\n        }  \r\n}  \r\n```\r\n\r\n## 3. 批量查询操作步骤\r\n\r\n- 在接口UserMapper中添加批量查询方法。\r\n\r\n```java\r\n/** \r\n    * 批量查询操作  \r\n    * @param ids \r\n    * @return \r\n    */  \r\n    public List<User> batchSelectUsers(List ids);  \r\n```\r\n\r\n- 在User.xml中添加批量查询操作的配置。\r\n\r\n```java\r\n<!-- 批量查询操作 -->  \r\n    <select id=\"batchSelectUsers\" resultType=\"User\">  \r\n        select *  \r\n        from mhc_user where id in  \r\n        <foreach collection=\"list\" index=\"index\" item=\"item\" open=\"(\" separator=\",\" close=\")\">  \r\n        #{item}  \r\n        </foreach>  \r\n    </select>  \r\n```\r\n\r\n​	由于批量查询的方法的返回为List<User>，所以resultType的值为User,即com.mahaochen.mybatis.domain.User。详见configuration.xml中。\r\n\r\n```xml\r\n<typeAliases>  \r\n        <!-- 注册实体Bean -->  \r\n        <typeAlias type=\"com.mahaochen.mybatis.domain.User\" alias=\"User\"/>  \r\n</typeAliases>  \r\n```\r\n\r\n- 创建批量操作的工具类BatchDataUtils，编写批量查询方法。\r\n\r\n```java\r\n/** \r\n    * 批量查询操作  \r\n    * @param ids \r\n    * @return \r\n    */  \r\n    public static List<User> batchSelectUsers(List ids){  \r\n        SqlSessionFactory ssf = MyBatisUtil.getSqlSessionFactory();  \r\n        SqlSession session = ssf.openSession();  \r\n        List<User> users = null;  \r\n        try {  \r\n            UserMapper userMapper = session.getMapper(UserMapper.class);  \r\n            users = userMapper.batchSelectUsers(ids);  \r\n        } catch (Exception e) {  \r\n            e.printStackTrace();  \r\n        } finally {  \r\n            MyBatisUtil.closeSession(session);  \r\n        }  \r\n        return users;  \r\n    }  \r\n}  \r\n```\r\n\r\n## 4. 批量更新操作步骤 \r\n\r\n- 在接口UserMapper中添加批量增加方法。\r\n\r\n```java\r\n/** \r\n     * 批量更新操作  \r\n     * @param ids \r\n     */  \r\n    public void batchUpdateUsers(List users);  \r\n```\r\n\r\n- 在User.xml中添加批量更新操作的配置。\r\n\r\n```java\r\n<!-- 批量更新操作 -->  \r\n    <!-- FOR MySQL mysql需要数据库连接配置&allowMultiQueries=true   \r\n        例如：jdbc:mysql://127.0.0.1:3306/mhc?allowMultiQueries=true -->  \r\n    <update id=\"batchUpdateUsers\" parameterType=\"java.util.List\">  \r\n        <foreach collection=\"list\" item=\"item\" index=\"index\" open=\"\" close=\"\" separator=\";\">  \r\n        update mhc_user   \r\n        <set>  \r\n            userName = #{item.userName}, password = #{item.password}  \r\n        </set>  \r\n        where id = #{item.id}  \r\n        </foreach>  \r\n    </update>  \r\n      \r\n    <!-- 【扩展知识】 FOR Oracle  有以下三种方式-->  \r\n    <!-- 方式一 -->  \r\n    <update id=\"batchUpdateUsers01\" parameterType=\"java.util.List\">  \r\n        <foreach collection=\"list\" item=\"item\" index=\"index\" open=\"begin\" close=\";end;\" separator=\";\" >   \r\n            update mhc_user   \r\n            <set>         \r\n                userName = #{item.userName}, password = #{item.password}  \r\n            </set>  \r\n            where id = #{item.id}  \r\n        </foreach>  \r\n    </update>  \r\n    <!-- 方式二 -->  \r\n    <update id=\"batchUpdateUsers02\" parameterType=\"java.util.List\">  \r\n        <foreach collection=\"list\" item=\"item\" index=\"index\" open=\"begin\" close=\"end;\" separator=\"\" >   \r\n            update mhc_user   \r\n            <set>         \r\n                userName = #{item.userName}, password = #{item.password}  \r\n            </set>  \r\n            where id = #{item.id};  \r\n        </foreach>  \r\n    </update>  \r\n    <!-- 方式三 -->  \r\n    <update id=\"batchUpdateUsers03\" parameterType=\"java.util.List\">  \r\n        begin  \r\n        <foreach collection=\"list\" item=\"item\" index=\"index\" separator=\"\" >   \r\n            update mhc_user   \r\n            <set>         \r\n                userName = #{item.userName}, password = #{item.password}  \r\n            </set>  \r\n            where id = #{item.id};  \r\n        </foreach>  \r\n        end;  \r\n    </update>  \r\n```\r\n\r\n​	由于批量更新的方法中参数为List，所以parameterType的值为java.util.List。\r\n\r\n- 创建批量的工具类\r\n\r\n```java\r\n/** \r\n    * 批量更新操作  \r\n    * @param users \r\n    */  \r\n   public static void batchUpdateUsers(List users){  \r\n    SqlSessionFactory ssf = MyBatisUtil.getSqlSessionFactory();  \r\n    SqlSession session = ssf.openSession();  \r\n      \r\n    try {  \r\n        UserMapper userMapper = session.getMapper(UserMapper.class);  \r\n        userMapper.batchUpdateUsers(users);  \r\n        session.commit();  \r\n    } catch (Exception e) {  \r\n        e.printStackTrace();  \r\n    } finally {  \r\n        MyBatisUtil.closeSession(session);  \r\n    }  \r\n   }  \r\n```\r\n\r\n', 1, 'post', 'publish', 'Mybatis', 'Java', 65, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (5, '什么是TCP/IP协议？', 'Pyspider-v2ex', 1523630086, 1527996068, '> 本文转载自公众号[技术特工队]，作者整理了一些TCP/IP协议簇中需要必知必会的十大问题，既是面试高频问题，又是程序员必备基础素养。\r\n\r\n![](http://omi0o6pp2.bkt.clouddn.com/blog/180206/GjBmBiCifL.png)\r\n\r\n## 一、TCP/IP模型\r\n\r\nTCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。\r\n\r\n基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180206/Ce5FELhDCi.png)\r\n\r\n- 物理层\r\n- 数据链路层\r\n- 网络层\r\n- 传输层\r\n- 会话层\r\n- 表示层\r\n- 应用层\r\n\r\nTCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。\r\n\r\n![](http://omi0o6pp2.bkt.clouddn.com/blog/180206/LEj7ldiF0F.png)\r\n\r\n上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。\r\n\r\n![](http://omi0o6pp2.bkt.clouddn.com/blog/180206/c9k1Lga25F.png)\r\n\r\n上图以HTTP协议为例，具体说明。\r\n\r\n## 二、数据链路层\r\n\r\n物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。![](http://omi0o6pp2.bkt.clouddn.com/blog/180206/h3JB8hAhFB.png)\r\n\r\n- 封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。\r\n- 透明传输:零比特填充、转义字符。\r\n- 可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。\r\n- 差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。\r\n\r\n## 三、网络层\r\n\r\n### 1. IP协议 \r\n\r\nIP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。\r\n\r\n#### 1.1 IP地址\r\n\r\n在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。\r\n\r\n32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。\r\n\r\n\r\n\r\n- A类IP地址: 0.0.0.0~127.255.255.255    \r\n- B类IP地址:128.0.0.0~191.255.255.255\r\n- C类IP地址:192.0.0.0~239.255.255.255\r\n\r\n\r\n\r\n#### 1.2 IP协议头\r\n\r\n![](http://omi0o6pp2.bkt.clouddn.com/blog/180206/5C1i8KDJD2.png)\r\n\r\n这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。\r\n\r\n这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。\r\n\r\n### 2. ARP及RARP协议\r\n\r\nARP 是根据IP地址获取MAC地址的一种协议。\r\n\r\nARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。\r\n\r\n如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。\r\n\r\n而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。\r\n\r\nRARP协议的工作与此相反，不做赘述。\r\n\r\n### 3. ICMP协议\r\n\r\nIP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。\r\n\r\n当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。\r\n\r\n## 四、ping\r\n\r\nping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。\r\n\r\n例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:\r\n\r\n![](http://omi0o6pp2.bkt.clouddn.com/blog/180206/8LA3JB7jJg.png)\r\n\r\nping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。\r\n\r\nping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。\r\n\r\n## 五、Traceroute\r\n\r\nTraceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。\r\n\r\nTraceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。\r\n\r\n![](http://omi0o6pp2.bkt.clouddn.com/blog/180206/EH3dj29LJ8.png)\r\n\r\n## 六、TCP/UDP\r\n\r\nTCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。\r\n\r\n![](http://omi0o6pp2.bkt.clouddn.com/blog/180206/5il9EJiI26.png)\r\n\r\n**面向报文**\r\n面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。\r\n\r\n**面向字节流**\r\n面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。\r\n\r\n关于拥塞控制，流量控制，是TCP的重点，后面讲解。\r\n\r\nTCP和UDP协议的一些应用\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180206/JCK656lKkG.png)\r\n\r\n#### 什么时候应该使用TCP？\r\n\r\n当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。\r\n\r\n#### 什么时候应该使用UDP？\r\n\r\n当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。\r\n\r\n## 七、DNS\r\n\r\nDNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。\r\n\r\n## 八、TCP连接的建立与终止\r\n\r\n#### 1.三次握手\r\n\r\nTCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180206/bf2K8eAl9j.png)\r\n\r\n\r\n\r\n第一次握手： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；\r\n\r\n第二次握手： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；\r\n\r\n第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。\r\n\r\n**为什么要三次握手？**\r\n为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\r\n\r\n具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”\r\n\r\n#### 2.四次挥手\r\n\r\n当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180206/m4CBF1jakB.png)\r\n\r\n\r\n\r\n第一次分手： 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；\r\n\r\n第二次分手： 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；\r\n\r\n第三次分手： 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；\r\n\r\n第四次分手： 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。\r\n\r\n**为什么要四次分手？**\r\nTCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。\r\n\r\n**为什么要等待2MSL？**\r\nMSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。\r\n原因有二：\r\n\r\n- 保证TCP协议的全双工连接能够可靠关闭\r\n- 保证这次连接的重复数据段从网络中消失\r\n\r\n第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。\r\n\r\n第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。\r\n\r\n## 九、TCP流量控制\r\n\r\n如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。\r\n\r\n利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。\r\n\r\n设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180206/45jIC6GkdD.png)\r\n\r\n从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。\r\n\r\nTCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。\r\n\r\n## 十、TCP拥塞控制\r\n\r\n#### 1.慢开始和拥塞避免\r\n\r\n发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。\r\n\r\n发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。\r\n\r\n**慢开始算法：**\r\n当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。\r\n因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。\r\n\r\n通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180206/7i29H3J243.png)\r\n\r\n\r\n\r\n每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。\r\n另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。\r\n\r\n为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下：\r\n\r\n- 当 cwnd < ssthresh 时，使用上述的慢开始算法。\r\n- 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。\r\n- 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。\r\n\r\n**拥塞避免**\r\n让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180206/cH16kge2dm.png)\r\n\r\n无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。\r\n\r\n这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。\r\n\r\n如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180206/fekAK1fe71.png)\r\n\r\n\r\n\r\n#### 2.快重传和快恢复\r\n\r\n**快重传**\r\n快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180206/K8Biic31i6.png)\r\n接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。\r\n\r\n显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。\r\n\r\n但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。\r\n\r\n快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。\r\n\r\n由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。\r\n\r\n**快恢复**\r\n与快重传配合使用的还有快恢复算法，其过程有以下两个要点：\r\n\r\n- 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。\r\n- 与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180206/A9gEIlJfkF.png)\r\n\r\n## 总结\r\n\r\n首先恭喜您，能够认真的阅读到这里，如果对部分理解不太明白，建议先将文章收藏起来，然后对不清楚的知识点进行查阅，然后在进行阅读，相应你会有更深的认知。\r\n\r\n\r\n\r\n-------------------------------------\r\n\r\n\r\n\r\n## 三次握手\r\n\r\n![](http://omi0o6pp2.bkt.clouddn.com/blog/180206/Fc4KlEbaj1.png)\r\n\r\n1. 客户端发送SYN（请求建立连接）\r\n2. 服务端发送ACK(针对SYN的确认应答)    SYN（请求建立连接）\r\n3. 客户端针向服务端发送ACK （针对SYN的确认应答）\r\n\r\n\r\n\r\n## 四次挥手\r\n\r\n![](http://omi0o6pp2.bkt.clouddn.com/blog/180206/k346Df7G8A.png)\r\n\r\n1. 客户端发送FIN（请求断开连接）\r\n2. 服务端发送ACK （针对FIN的确认应答）\r\n3. FIN（请求断开连接）\r\n4. ACK（针对FIN的确认应答）\r\n\r\n', 1, 'post', 'publish', 'TCP/IP', '默认分类', 62, 1, 1, 1, 1);
INSERT INTO `t_contents` VALUES (6, '深入解析Java垃圾回收机制', 'Java-16-lession', 1524234886, 1527518476, '> 转载自 [深入解析Java垃圾回收机制](https://liuchi.coding.me/2017/08/05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)\r\n\r\n>- 引入垃圾回收\r\n>- 哪些内存需要回收？\r\n>  - 引用计数法\r\n>  - 可达性分析\r\n>- 如何回收\r\n>  - Marking 标记\r\n>  - Normal Deletion 清除\r\n>  - Deletion with Compacting 压缩\r\n>- 为什么需要分代收集？\r\n>- JVM的分代\r\n>  - 新生代\r\n>  - 老年代\r\n>  - 永久代\r\n>- 分代垃圾收集过程详述\r\n\r\n# 1. 引入垃圾回收\r\n\r\n> 程序计数器、 虚拟机栈、 本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。 每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。 而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存—–《深入理解Java虚拟机》\r\n\r\n自动垃圾回收机制就是寻找Java堆中的对象，并对对象进行分类判别，寻找出正在使用的对象和已经不会使用的对象，然后把那些不会使用的对象从堆上清除。\r\n\r\n自动垃圾回收机制就是要解决三个问题：\r\n\r\n- 那些内存需要回收？\r\n- 什么时候回收？\r\n- 如何回收？\r\n\r\n<!-- more-->\r\n\r\n# 2. 哪些内存需要回收？\r\n\r\n## 2.1 引用计数法\r\n\r\n对于第一个问题，也就是判断是否还需要使用，最简单的方法就是通过目前是否有引用指向这个对象，如果没有就说明这个对象不会再被使用了，如果有就说明这个对象可能还会继续被使用，这种通过引用是否存在的方法就叫做引用计数法，但这个方法存在一个问题就是无法解决对象循环引用的问题，因此又出现了可达性分析的方法来判断对象是否可以被会回收。\r\n\r\n## 2.2 可达性分析\r\n\r\n这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。\r\n\r\n在Java语言中，可作为GC Roots的对象包括下面几种：\r\n\r\n- 虚拟机栈（栈帧中的本地变量表）中引用的对象。\r\n- 方法区中类静态属性引用的对象。\r\n- 方法区中常量引用的对象。\r\n- 本地方法栈中JNI（即一般说的Native方法）引用的对象。\r\n\r\n# 3. 如何回收\r\n\r\n垃圾收集器通常会帮我们在后台自动进行垃圾回收。关于具体的回收过程只要有以下这些步骤\r\n\r\n	- Step 1: Marking 标记\r\n\r\n第一步就是标记，也就是垃圾收集器会找出那些需要回收的对象所在的内存和不需要回收的对象所在的内存，并把它们标记出来，简单的说，也就是先找出垃圾在哪\r\n\r\n![image.png](http://upload-images.jianshu.io/upload_images/1234352-420049faf427a7ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n所有堆中的对象都会被扫描一遍，以此来确定回收的对象，所以这通常会是一个相对比较耗时的过程\r\n\r\n- Step 2: Normal Deletion\r\n\r\n  垃圾收集器会清除掉上一步标记出来的那些需要回收的对象区域\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-8a00dad3f360aaae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n存在的问题就是碎片问题：\r\n\r\n标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\r\n\r\n- Step 2a: Deletion with Compating 压缩\r\n\r\n  由于简单的清除可能会存在碎片的问题，所以又出现了压缩清除的方法，也就是先清除需要回收的对象，然后再对内存进行压缩操作，将内存分成可用和不可用两大部分\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-9a5942233a60c0bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n\r\n\r\n\r\n\r\n# 4. 为什么需要分代收集？\r\n\r\n就像前文所述，标记对象和压缩内存的过程在JVM中是不高效的，分配的对象越多，垃圾收集的时间就越长。但是，经过一些经验型性的统计分析表明，一个程序中大部分对象都是短命的！\r\n\r\n下图就是一个类似的统计数据，纵坐标表示分配对象所占用的内存大小，横坐标表示自分配对象过去的时间\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-32fa64dd7cfd57a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n从图中我们看到，大部分对象没活多久就死了，存活较久的只是少类对象\r\n\r\n# 5. JVM的分代\r\n\r\n为了增大垃圾收集的效率，所以JVM将堆进行分代，分为不同的部分，一般有三部分，新生代，老年代和永久代\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-80d8ad7f6a126106.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n## 5.1 新生代\r\n\r\n所有新new出来的对象都会最先出现在新生代中，当新生代这部分内存满了之后，就会发起一次垃圾收集事件，这种发生在新生代的垃圾收集称为Minor collections。这种收集通常比较快，因为新生代的大部分对象都是需要回收的，那些暂时无法回收的就会被移动到老年代。\r\n\r\n**Stop the World**事件-所有minor garbage collections都是**Stop the World**事件，也就是意味着所有的应用线程都需要停止，直到垃圾回收的操作全部完成。类似于\r\n\r\n“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”\r\n\r\n## 5.2 老年代\r\n\r\n老年代用来存储那些存活时间较长的对象。一般来说，我们会给新生代的对象限定一个存活的时间，当达到这个时间还没有被收集的时候就会被移动到老年代中。老年代区域的垃圾收集叫做major garbage collection\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-b08bf6069ee7366c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\nMajor garbage collection也是一个**Stop the World**事件。通常Major garbage collection都相对比较慢，因为老年代的收集包括了对所有对象的收集，也就是同时需要收集新生代和老年代的对象。\r\n\r\n## 5.3 永久代\r\n\r\nThe Permanent generation contains metadata required by the JVM to describe the classes and methods used in the application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. In addition, Java SE library classes and methods may be stored here.\r\n\r\nClasses may get collected (unloaded) if the JVM finds they are no longer needed and space may be needed for other classes. The permanent generation is included in a full garbage collection.\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-f7f32e39af803854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n# 6. 分代垃圾收集过程详述\r\n\r\n我们已经知道垃圾回收所需要的方法和堆内存的分代，那么接下来我们就来具体看一下垃圾回收的具体过程\r\n\r\n- 第一步 所有new出来的对象都会最先分配到新生代区域中，两个survivor区域初始化是为空的\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-ed812d174ca6c8c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n- 第二步，当eden区域满了之后，就引发一次 minor garbagecollection\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-d3746363a41a7c3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n- 第三步，当在minor garbage collection，存活下来的对象就会被移动到S0survivor区域\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-eb04dc5ddf426ba1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n\r\n\r\n- 第四步，然后当eden区域又填满的时候，又会发生下一次的垃圾回收，存活的对象会被移动到survivor区域而未存活对象会被直接删除。但是，不同的是，在这次的垃圾回收中，存活对象和之前的survivor中的对象都会被移动到s1中。一旦所有对象都被移动到s1中，那么s2中的对象就会被清除，仔细观察图中的对象，数字表示经历的垃圾收集的次数。目前我们已经有不同的年龄对象了。\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-2ef7443435b7de67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n- 第五步，下一次垃圾回收的时候，又会重复上次的步骤，清除需要回收的对象，并且又切换一次survivor区域，所有存活的对象都被移动至s0。eden和s1区域被清除。\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-c4ca47aa891ffeb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n- 第六步，重复以上步骤，并记录对象的年龄，当有对象的年龄到达一定的阈值的时候，就将新生代中的对象移动到老年代中。在本例中，这个阈值为8.\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-3a5073d424ad3778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n- 第七步，接下来垃圾收集器就会重复以上步骤，不断的进行对象的清除和年代的移动\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-038cdad64f06b7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n- 最后，我们观察上述过程可以发现，大部分的垃圾收集过程都是在新生代进行的，直到老年代中的内存不够用了才会发起一次 major GC，会进行标记和整理压缩。\r\n\r\n![](http://upload-images.jianshu.io/upload_images/1234352-a4fee4707be5d7e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\r\n\r\n# 7. 总结\r\n\r\n“地球人都知道，Java有个东西叫垃圾收集器，它让创建的对象不需要像c/cpp那样delete、free掉，你能不能谈谈，GC是在什么时候，对什么东西，做了什么事情？”\r\n\r\n## 7.1 “什么时候”\r\n\r\n我自己分析一下这个问题，首先是“什么时候”，不同层次的回答从低到高排列： \r\n\r\n1. 系统空闲的时候。\r\n\r\n   分析：这种回答大约占30%，遇到的话一般我就会准备转向别的话题，譬如算法、譬如SSH看看能否发掘一些他擅长的其他方面。\r\n\r\n2. 系统自身决定，不可预测的时间/调用System.gc()的时候。\r\n\r\n   分析：这种回答大约占55%，大部分应届生都能回答到这个答案，起码不能算错误是吧，后续应当细分一下到底是语言表述导致答案太笼统，还是本身就只有这样一个模糊的认识。 \r\n\r\n3. 能说出新生代、老年代结构，能提出minor gc/full gc\r\n\r\n   分析：到了这个层次，基本上能说对GC运作有概念上的了解，譬如看过《深入JVM虚拟机》之类的。这部分不足10%。\r\n\r\n4. **能说明minor gc/full gc的触发条件、OOM的触发条件，降低GC的调优的策略。**\r\n\r\n   **minor gc的触发条件：eden满了；**\r\n\r\n   **full gc的触发条件：升到老年代的对象大于老年代剩余空间时，或者小于被HandlePromotionFaiure参数强制full gc；**\r\n\r\n   **OOM(out of memory)的触发条件：gc与非gc时间耗时超过GCTimeRatio的限制引发OOM；**\r\n\r\n   **降低GC的调优的策略：通过NewRatio控制新生代老年代的比例，通过MaxTenuringThreshold控制进入老年前生存次数等；**\r\n\r\n\r\n\r\n## 7.2 “对什么东西” \r\n\r\n1. 不使用的对象\r\n\r\n   分析：相当于没有回答，问题就是在问什么对象才是“不使用的对象”。大约占30%。 \r\n\r\n2. 超出作用域的对象/引用计数为空的对象。\r\n\r\n   分析：这2个回答站了60%，相当高的比例，估计学校教java的时候老师就是这样教的。第一个回答没有解决我的疑问，gc到底怎么判断哪些对象在不在作用域的？至于引用计数来判断对象是否可收集的，我可以会补充一个下面这个例子让面试者分析一下obj1、obj2是否会被GC掉？ \r\n\r\n   ​\r\n\r\n   ​    class C{ \r\n   ​         public Object x; \r\n   ​    } \r\n   ​    C obj1、obj2 = new C(); \r\n   ​    obj1.x = obj2; \r\n   ​    obj2.x = obj1; \r\n   ​    obj1、obj2 = null; \r\n\r\n\r\n\r\n3. 从gc root开始搜索，搜索不到的对象。\r\n\r\n   分析：根对象查找、标记已经算是不错了，小于5%的人可以回答道这步，估计是引用计数的方式太“深入民心”了。基本可以得到这个问题全部分数。 \r\n   ​    PS：有面试者在这个问补充强引用、弱引用、软引用、幻影引用区别等，不是我想问的答案，但可以加分。 \r\n\r\n\r\n\r\n4. **从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。**\r\n\r\n   分析：我期待的答案。但是的确很少面试者会回答到这一点，所以在我心中回答道第3点我就给全部分数。 \r\n\r\n\r\n\r\n\r\n## 7.3 “做什么事情”\r\n\r\n1. **删除不使用的对象，腾出内存空间。**\r\n\r\n   分析：同问题2第一点。40%。 \r\n\r\n2. **补充一些诸如停止其他线程执行、运行finalize等的说明。** \r\n\r\n    分析：起码把问题具体化了一些，如果像答案1那样我很难在回答中找到话题继续展开，大约占40%的人。 \r\n      ​       补充一点题外话，面试时我最怕遇到的回答就是“这个问题我说不上来，但是遇到的时候我上网搜一下能做出来”。做程序开发确实不是去锻炼茴香豆的“茴”有几种写法，不死记硬背我同意，我不会纠语法、单词，但是多少你说个思路呀，要直接回答一个上网搜，我完全没办法从中获取可以评价应聘者的信息，也很难从回答中继续发掘话题展开讨论。建议大家尽量回答引向自己熟悉的，可讨论的领域，展现给面试官最擅长的一面。 \r\n\r\n3. **能说出诸如新生代做的是复制清理、from survivor、to survivor是干啥用的、老年代做的是标记清理、标记清理后碎片要不要整理、复制清理和标记清理有有什么优劣势等。** \r\n\r\n    分析：也是看过《深入JVM虚拟机》的基本都能回答道这个程度，其实到这个程度我已经比较期待了。同样小于10%。 \r\n\r\n4. **除了3外，还能讲清楚串行、并行（整理/不整理碎片）、CMS等搜集器可作用的年代、特点、优劣势，并且能说明控制/调整收集器选择的方式。**\r\n\r\n\r\n\r\n', 1, 'post', 'publish', 'Java垃圾回收', 'Java', 51, 3, 1, 1, 1);
INSERT INTO `t_contents` VALUES (7, '赠与今年的大学毕业生（胡适）', NULL, 1525399722, 1527518700, '这一两个星期里，各地的大学都有毕业的班次，都有很多的毕业生离开学校去开始他们的成人事业。学生的生活是一种享有特殊优待的生活，不妨幼稚一点，不妨吵吵闹闹，社会都能纵容他们，不肯严格的要他们负行为的责任。现在他们要撑起自己的肩膀来挑他们自己的担子了。在这个国难最紧急的年头，他们的担子真不轻！ 我们祝他们的成功，同时也不忍不依据我们自己的经验，赠与他们几句送行的赠言——虽未必是救命毫毛，也许作个防身的锦囊罢！\r\n\r\n你们毕业之后，可走的路不出这几条：绝少数的人还可以在国内或国外的研究院继续作学术研究；少数的人可以寻着相当的职业；此外还有做官，办党，革命三条路；此外就是在家享福或者失业闲居了。第一条继续求学之路，我们可以不讨论。走其余几条路的人，都不能没有堕落的危险。堕落的方式很多，总括起来，约有这两大类：\r\n\r\n第一是容易抛弃学生时代的求知识的欲望。你们到了实际社会里，往往所用非所学，往往所学全无用处，往往可以完全用不着学问，而一样可以胡乱混饭吃，混官做。在这种环境里，即使向来抱有求知识学问的决心的人，也不免心灰意懒，把求知的欲望渐渐冷淡下去。况且学问是要有相当的设备的；书籍，试验室，师友的切磋指导，闲暇的工夫，都不是一个平常要糊口养家的人所能容易办到的。没有做学问的环境，又谁能怪我们抛弃学问呢？\r\n\r\n第二是容易抛弃学生时代的理想的人生的追求。少年人初次与冷酷的社会接触，容易感觉理想与事实相去太远，容易发生悲观和失望。多年怀抱的人生理想，改造的热诚，奋斗的勇气，到此时候，好像全不是那么一回事。渺小的个人在那强烈的社会炉火里，往往经不起长时期的烤炼就镕化了，一点高尚的理想不久就幻灭了。抱着改造社会的梦想而来，往往是弃甲曳兵而走，或者做了恶势力的俘虏。你在那俘虏牢狱里，回想那少年气壮时代的种种理想主义，好像都成了自误误人的迷梦！从此以后，你就甘心放弃理想人生的追求，甘心做现成社会的顺民了。\r\n\r\n要防御这两方面的堕落，一面要保持我们求知识的欲望，一面要保持我们对于理想人生的追求。有什么好法子呢？依我个人的观察和经验，有三种防身的药方是值得一试的。\r\n\r\n<!-- more -->\r\n\r\n第一个方子只有一句话：“总得时时寻一两个值得研究的问题！”问题是知识学问的老祖宗；古今来一切知识的产生与积聚，都是因为要解答问题，——要解答实用上的困难或理论上的疑难。所谓“为知识而求知识”，其实也只是一种好奇心追求某种问题的解答，不过因为那种问题的性质不必是直接应用的，人们就觉得这是“无所为”的求知识了。我们出学校之后，离开了做学问的环境，如果没有一个两个值得解答的疑难问题在脑子里盘旋，就很难继续保持追求学问的热心。可是，如果你有了一个真有趣的问题天天逗你去想他，天天引诱你去解决他，天天对你挑衅笑你无可奈他，——这时候，你就会同恋爱一个女子发了疯一样，坐也坐不下，睡也睡不安，没工夫也得偷出工夫去陪她，没钱也得撙衣节食去巴结她。没有书，你自会变卖家私去买书；没有仪器，你自会典押衣服去置办仪器；没有师友，你自会不远千里去寻师访友。你只要能时时有疑难问题来逼你用脑子，你自然会保持发展你对学问的兴趣，即使在最贫乏的智识环境中，你也会慢慢的聚起一个小图书馆来，或者设置起一所小试验室来。所以我说：第一要寻问题，脑子里没有问题之日，就是你的智识生活寿终正寝之时！古人说，“待文王而兴者，凡民也。若夫豪杰之士，虽无文王犹兴。”试想葛理略（Galieo）和牛敦(Newton)有多少藏书？有多少仪器？他们不过是有问题而已。有了问题而后，他们自会造出仪器来解答他们的问题。没有问题的人们，关在图书馆里也不会用书，锁在试验室里也不会有什么发现。\r\n\r\n第二个方子也只有一句话：“总得多发展一点非职业的兴趣。”离开学校之后，大家总得寻个吃饭的职业。可是你寻得的职业未必就是你所学的，或者未必是你所心喜的，或者是你所学而实在和你的性情不想近的。在这种状况之下，工作就往往成了苦工，就不感觉兴趣了。为糊口而作那种非“性之所近而力之所能勉”的工作，就很难保持求知的兴趣和生活的理想主义。最好的救济方法只有多多发展职业以外的正当兴趣与活动。一个人应该有他的职业，又应该有他的非职业的顽艺儿，可以叫做业余活动。凡一个人用他的闲暇来做的事业，都是他的业余活动。往往他的业余活动比他的职业还更重要，因为一个人的前程往往会靠他怎样用他的闲暇时间。他用他的闲暇来打马将，他就成个赌徒；你用你的闲暇来做社会服务，你也许成个社会改革者；或者你用你的闲暇去研究历史，你也许成个史学家。你的闲暇往往定你的终身。英国十九世纪的两个哲人，弥儿（J.S.Mill）终身做东印度公司的秘书，然而他的业余工作使他在哲学上，经济学上，政治思想史上都占一个很高的位置；斯宾塞（Spencer）是一个测量工程师，然而他的业余工作使他成为前世纪晚期世界思想界的一个重镇。古来成大学问的人，几乎没有一个不是善用他的闲暇时间的。特别在这个组织不健全的中国社会，职业不容易适合我们性情，我们要想生活不苦痛或不堕落，只有多方发展业余的兴趣，使我们的精神有所寄托，使我们的剩余精力有所施展。有了这种心爱的顽艺儿，你就做六个钟头的抹桌子工夫也不会感觉烦闷了，因为你知道，抹了六点钟的桌子之后，你可以回家去做你的化学研究，或画完你的大幅山水，或写你的小说戏曲，或继续你的历史考据，或做你的社会改革事业。你有了这种称心如意的活动，生活就不枯寂了，精神也就不会烦闷了。\r\n\r\n第三个方子也只有一句话：“你总得有一点信心。”我们生当这个不幸的时代，眼中所见，耳中所闻，无非是叫我们悲观失望的。特别是在这个年头毕业的你们，眼见自己的国家民族沉沦到这步田地，眼看世界只是强权的世界，望极天边好像看不见一线的光明，——在这个年头不发狂自杀，已算是万幸了，怎么还能够希望保持一点内心的镇定和理想的信心呢？我要对你们说：这时候正是我们培养我们的信心的时候！只要我们有信心，我们还有救。古人说：“信心（Faith）可以移山。”又说：“只要工夫深，生铁磨成绣花针。”你不信吗？当拿破仑的军队征服普鲁士占据柏林的时候，有一位穷教授叫做菲希特（Fichte）的，天天在讲堂上劝他的国人要有信心，要信仰他们的民族是有世界的特殊使命的，是必定要复兴的。菲希特死的时候（1814），谁也不能预料德意志统一帝国何时可以实现。然而不满五十年，新的统一的德意志帝国居然实现了。\r\n\r\n一个国家的强弱盛衰，都不是偶然的，都不能逃出因果的铁律的。我们今日所受的苦痛和耻辱，都只是过去种种恶因种下的恶果。我们要收将来的善果，必须努力种现在的新因。一粒一粒的种，必有满仓满屋的收，这是我们今日应该有的信心。\r\n\r\n我们要深信：今日的失败，都由于过去的不努力。\r\n\r\n我们要深信：今日的努力，必定有将来的大收成\r\n\r\n佛典里有一句话：“福不唐捐。”唐捐就是白白的丢了，我们也应该说：“功不唐捐！”没有一点努力是会白白的丢了的。在我们看不见想不到的时候，在我们看不见想不到的方向，你瞧！你下的种子早已生根发叶开花结果了！\r\n\r\n你不信吗？法国被普鲁士打败之后，割了两省地，赔了五十万万佛郎的赔款。这时候有一位刻苦的科学家巴斯德（Pasteur）终日埋头在他的试验室里做他的化学试验和微菌学研究。他是一个最爱国的人，然而他深信只有科学可以救国。他用一生的精力证明了三个科学问题：（1）每一种发酵作用都是由于一种微菌的发展；（2）每一种传染病都是由于一种微菌在生物体中的发展；（3）传染病的微菌，在特殊的培养之下，可以减轻毒力，使它从病菌变成防病的药苗。——这三个问题，在表面上似乎都和救国大事业没有多大的关系。然而从第一个问题的证明，巴斯德定出做醋酿酒的新法，使全国的酒醋业每年减除极大的损失。从第二个问题的证明，巴斯德教全国的蚕丝业怎样选种防病，教全国的畜牧农家怎样防止牛羊瘟疫，又教全世界的医学界怎样注重消毒以减除外科手术的死亡率。从第三个问题的证明，巴斯德发明了牲畜的脾热瘟的疗治药苗，每年替法国农家灭除了二千万佛郎的大损失；又发明了疯狗咬毒的治疗法，救济了无数的生命。所以英国的科学家赫胥黎（Huxley）在皇家学会里称颂巴斯德的功绩道：“法国给了德国五十万万佛郎的赔款，巴斯德先生一个人研究科学的成绩足够还清这一笔赔款了。”\r\n\r\n巴斯德对于科学有绝大的信心，所以他在国家蒙奇辱大难的时候，终不肯抛弃他的显微镜与试验室。他绝不想他的显微镜底下能偿还五十万万佛郎的赔款，然而在他看不见想不到的时候，他已收获了科学救国的奇迹了。\r\n\r\n朋友们，在你最悲观最失望的时候，那正是你必须鼓起坚强的信心的时候。你要深信：天下没有白费的努力。成功不必在我，而功力必不唐捐。\r\n\r\n(二十一，六，二十七夜)\r\n\r\n\r\n', 1, 'post', 'publish', '哲理', 'Java', 123, 1, 1, 1, 1);
INSERT INTO `t_contents` VALUES (8, '喜欢听的歌', NULL, 1525658654, 1527517919, '## Hi\r\n\r\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=364899&auto=0&height=66\"></iframe>', 1, 'post', 'publish', '音乐', '默认分类', 176, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (9, '@ResponseBody 和 @RequestBody 的作用', NULL, 1526546643, 1527517894, '先提一嘴 @RequestMapping(“url”)，这里的 url写的是请求路径的一部分，一般作用在 Controller的方法上，作为请求的映射地址。\r\n\r\n代码：\r\n\r\n```java\r\n@RequestMapping(value = \"/test\")//类级别映射，可以没有，一般用于减少书写量\r\npublic class myController {\r\n    //方法级别映射，必须有，那么这个方法的访问地址就是/test/aaa，请求到的页面就是test.jsp【当然，这里的.jsp需要在配置文件中配置】\r\n    @RequestMapping(value = \"/aaa\")\r\n    public String getMyName() {\r\n        return \"test\";\r\n    }\r\n}\r\n```\r\n\r\n那么@ResponseBody呢？\r\n\r\n```\r\n@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。\r\n\r\n@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。\r\n```\r\n\r\n**举个例子：**\r\n\r\n<!-- more -->\r\n\r\n前台异步请求：\r\n\r\n```\r\nfunction loginAction() {\r\n\r\n    // 获取用户输入的账号和密码\r\n    var name = $(\'#count\').val();\r\n    var password = $(\'#password\').val();\r\n\r\n    $.ajax({\r\n        url : \'account/login.do\',\r\n        type : \'post\',\r\n        // data对象中的属性名要和服务端控制器的参数名一致 login(name, password)\r\n        data : {\r\n            \'name\' : name,\r\n            \'password\' : password\r\n        },\r\n        dataType : \'json\',\r\n        success : function(result) {\r\n            if (result.state == 0) {\r\n                // 登录成功，设置cookie并跳转edit.html\r\n                addCookie(\'userId\', result.data.id);\r\n                addCookie(\'nick\', result.data.nick);\r\n                location.href = \'edit.html\';\r\n            } else {\r\n                // 登录失败\r\n                var msg = result.message;\r\n                $(\'#sig_in\').next().html(msg);\r\n                $(\'#sig_in\').next().css(\"color\", \"red\");\r\n            }\r\n        },\r\n        error : function(e) {\r\n            alert(\"系统异常\");\r\n        }\r\n    });\r\n    $(\'#password\').val(\"\");\r\n}\r\n	\r\n```\r\n\r\n后台 Controller类中对应的方法：\r\n\r\n```java\r\n@RequestMapping(\"/login.do\")\r\n@ResponseBody\r\npublic Object login(String name, String password, HttpSession session) {\r\n    user = userService.checkLogin(name, password);\r\n    session.setAttribute(\"user\", user);\r\n    return new JsonResult(user);\r\n}\r\n```\r\n\r\n@RequestBody呢？\r\n\r\n```java\r\n@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。\r\n```\r\n\r\n比如上面的登录后台代码可以改为：\r\n\r\n```\r\n    @RequestMapping(\"/login.do\")\r\n    @ResponseBody\r\n    public Object login(@RequestBody User loginUuser, HttpSession session) {\r\n        user = userService.checkLogin(loginUser);\r\n        session.setAttribute(\"user\", user);\r\n        return new JsonResult(user);\r\n    }\r\n```', 1, 'post', 'publish', 'java学习', '默认分类,Java', 31, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (10, '58赶集的mysql军规', NULL, 1526546837, 1527996008, '> 本文转载自公众号    架构师之路\r\n>\r\n> 总是在灾难发生后，才想起容灾的重要性。\r\n>\r\n> 总是在吃过亏后，才记得曾经有人提醒过。\r\n\r\n## 一，核心军规\r\n\r\n- **不在数据库做计算**，cpu计算务必移至业务层\r\n- 控制单表数据量，单表记录控制在千万级\r\n- 控制列数量，字段数控制在20以内\r\n- 平衡范式与冗余，**为提高效率可以牺牲范式设计，冗余数据**\r\n- 拒绝3B(big)，大sql，大事务，大批量\r\n\r\n## 二，字段类军规\r\n\r\n- 用好数值类型\r\n  tinyint(1Byte)\r\n  smallint(2Byte)\r\n  mediumint(3Byte)\r\n  int(4Byte)\r\n  bigint(8Byte)\r\n  bad case：int(1)/int(11)\r\n\r\n- 有些字符转化为数字\r\n  用int而不是char(15)存储ip\r\n\r\n- 优先使用enum或set\r\n  例如：`sex` enum (‘F’, ‘M’)\r\n\r\n- **避免使用NULL字段**\r\n\r\n  NULL字段很难查询优化\r\n\r\n  NULL字段的索引需要额外空间\r\n\r\n  NULL字段的复合索引无效\r\n\r\n  bad case：\r\n  `name` char(32) default null\r\n  `age` int not null\r\n  good case：\r\n  `age` int not null default 0\r\n\r\n- 不在数据库里存图片\r\n\r\n## 三，索引类军规\r\n\r\n- 谨慎合理使用索引\r\n\r\n  改善查询、减慢更新\r\n  索引一定不是越多越好（能不加就不加，要加的一定得加）\r\n  覆盖记录条数过多不适合建索引，例如“性别”\r\n\r\n- 字符字段必须建前缀索引\r\n\r\n- 不在索引做列运算\r\n\r\n  bad case：\r\n  select id where age +1 = 10;\r\n\r\n- innodb主键合理使用自增列\r\n  主键建立聚簇索引\r\n  主键不应该被修改\r\n  **字符串不应该做主键**\r\n  如果不指=p定主键，innodb会使用唯一且非空值索引代替\r\n\r\n- **不用外键，请由程序保证约束**\r\n\r\n## 四，sql类军规\r\n\r\n- sql语句尽可能简单\r\n  一条sql只能在一个cpu运算\r\n  大语句拆小语句，减少锁时间\r\n  一条大sql可以堵死整个库\r\n- 简单的事务\r\n  事务时间尽可能短\r\n  bad case：\r\n  上传图片事务\r\n- 避免使用触发器，用户自定义函数，请由程序取而代之\r\n- 不用select *\r\n  消耗cpu，io，内存，带宽\r\n  这种程序不具有扩展性\r\n- OR改写为IN()\r\n- OR改写为UNION\r\n\r\n*画外音：最新的mysql内核已经进行了相关优化*\r\n\r\n- limit高效分页\r\n\r\n  limit越大，效率越低\r\n\r\n  select id from t limit 10000, 10;\r\n\r\n  应该改为 =>\r\n\r\n  select id from t where id > 10000 limit 10;\r\n\r\n- 使用union all替代union，union有去重开销\r\n\r\n- **尽量不用连接join**\r\n\r\n- **务必请使用“同类型”进行比较**，否则可能全表扫描\r\n\r\n- 打散批量更新\r\n\r\n- 使用性能分析工具\r\n  show profile;\r\n  mysqlsla;\r\n  mysqldumpslow;\r\n  explain;\r\n  show slow log;\r\n  show processlist;\r\n  show query_response_time(percona)', 1, 'post', 'publish', 'mysql', 'Web服务器', 39, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (11, '大型网站架构演化历程', NULL, 1526546855, 1527996023, '本文转载自公众号 Hollis\r\n\r\n> 大型网站的挑战主要来自庞大的用户，高并发的访问和海量数据，任何简单的业务一旦需要处理数以P计的数据和面对数以亿计的用户，问题就会变得棘手。大型网站架构主要就是解决这类问题。更多内容也可以阅读各大互联网公司架构演进之路汇总、大型网站架构技术一览两篇文章。\r\n\r\n本文内容大部分来自《大型网站技术架构》,这本书很值得一看，强烈推荐。\r\n\r\n## 大型网站系统的特点\r\n\r\n### 高并发，大流量\r\n\r\n需要面对高并发用户，大流量访问。Google 日均 PV 35 亿，日 IP 访问数 3 亿；腾讯 QQ 的最大在线用户数 1.4 亿（2011年数据）。\r\n\r\n### 高可用\r\n\r\n系统 7 x 24 小时不间断服务。\r\n\r\n### 海量数据\r\n\r\n需要存储、管理海量数据，需要使用大量服务器。Facebook 每周上传的照片数量接近 10 亿，百度收录的网页数目有数百亿，Google 有近百万台服务器为全球用户提供服务。\r\n\r\n\r\n### 用户分布广泛，网络情况复杂\r\n\r\n许多大型互联网站都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别。在国内，还有各个运营商网络互通难的问题。\r\n\r\n### 安全环境恶劣\r\n\r\n由于互联网的开放性，使得互联网站更容易受到攻击，大型网站几乎每天都会被黑客攻击。\r\n\r\n### 需求快速变更，发布频繁\r\n\r\n和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率极高。一般大型网站的产品每周都有新版本发布上线，中小型网站的发布更频繁，有时候一天会发布几十次。\r\n\r\n### 渐进式发展\r\n\r\n几乎所有的大型互联网网站都是从一个小网站开始，渐进地发展起来的。Facebook 是扎克伯格同学在哈佛大学的宿舍里开发的；Google 的第一台服务器部署在斯坦福大学的实验室；阿里巴巴是在马云家的客厅诞生的。好的互联网产品都是慢慢运营出来的，不是一开始就开发好的，这也正好与网站架构的发展演化过程对应。\r\n\r\n## 大型网站架构演化发展历程\r\n\r\n大型网站的技术挑战主要来自于庞大的用户，高并发的访问和海量的数据，任何简单的业务一旦需要处理数以 P 计的数据和面对数以亿计的用户，问题就会变得很棘手。大型网站架构主要解决这类问题。\r\n\r\n### 初始阶段的网站架构\r\n\r\n大型网站都是从小型网站发展而来，网站架构也是一样，是从小型网站架构逐步演化而来。小型网站最开始没有太多人访问，只需要一台服务器就绰绰有余，这时的网站架构如下图所示：\r\n\r\n\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180317/7hiiFHm7cE.jpg)\r\n\r\n\r\n\r\n应用程序、数据库、文件等所有资源都在一台服务器上。\r\n\r\n### 应用服务和数据服务分离\r\n\r\n随着网站业务的发展，一台服务器逐渐不能满足需求：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足。这时就需要将应用和数据分离。应用和数据分离后整个网站使用3台服务器：应用服务器、文件服务器和数据库服务器。这 3 台服务器对硬件资源的要求各不相同：\r\n\r\n> 应用服务器需要处理大量的业务逻辑，因此需要更快更强大的CPU；\r\n>\r\n> 数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的磁盘和更大的内存；\r\n>\r\n> 文件服务器需要存储大量用户上传的文件，因此需要更大的硬盘。\r\n\r\n此时，网站系统的架构如下图所示：\r\n\r\n\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180317/3hHC1I9Lbg.jpg)\r\n\r\n\r\n\r\n应用和数据分离后，不同特性的服务器承担不同的服务角色，网站的并发处理能力和数据存储空间得到了很大改善，支持网站业务进一步发展。但是随着用户逐渐增多，网站又一次面临挑战：数据库压力太大导致访问延迟，进而影响整个网站的性能，用户体验受到影响。这时需要对网站架构进一步优化。\r\n\r\n### 使用缓存改善网站性能\r\n\r\n网站访问的特点和现实世界的财富分配一样遵循二八定律：80% 的业务访问集中在20% 的数据上。既然大部分业务访问集中在一小部分数据上，那么如果把这一小部分数据缓存在内存中，就可以减少数据库的访问压力，提高整个网站的数据访问速度，改善数据库的写入性能了。 网站使用的缓存可以分为两种：缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器上的远程缓存。\r\n\r\n> 本地缓存的访问速度更快一些，但是受应用服务器内存限制，其缓存数据量有限，而且会出现和应用程序争用内存的情况。\r\n>\r\n> 远程分布式缓存可以使用集群的方式，部署大内存的服务器作为专门的缓存服务器，可以在理论上做到不受内存容量限制的缓存服务。\r\n\r\n\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180317/cEB61BcmHc.webp)\r\n\r\n\r\n\r\n使用缓存后，数据访问压力得到有效缓解，但是单一应用服务器能够处理的请求连接有限，在网站访问高峰期，应用服务器成为整个网站的瓶颈。\r\n\r\n### 使用应用服务器集群改善网站的并发处理能力\r\n\r\n使用集群是网站解决高并发、海量数据问题的常用手段。当一台服务器的处理能力、存储空间不足时，不要企图去更换更强大的服务器，对大型网站而言，不管多么强大的服务器，都满足不了网站持续增长的业务需求。这种情况下，更恰当的做法是增加一台服务器分担原有服务器的访问及存储压力。 **对网站架构而言，只要能通过增加一台服务器的方式改善负载压力，就可以以同样的方式持续增加服务器不断改善系统性能，从而实现系统的可伸缩性**。应用服务器实现集群是网站可伸缩架构设计中较为简单成熟的一种，如下图所示：\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180317/B2CBad50C2.webp)\r\n\r\n\r\n\r\n通过负载均衡调度服务器，可以将来自用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上，如果有更多用户，就在集群中加入更多的应用服务器，使应用服务器的压力不再成为整个网站的瓶颈。\r\n\r\n### 数据库读写分离\r\n\r\n网站在使用缓存后，使对大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作（缓存访问不命中、缓存过期）和全部的写操作都需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。 目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。网站利用数据库的这一功能，实现数据库读写分离，从而改善数据库负载压力。如下图所示：\r\n\r\n### 数据库读写分离\r\n\r\n网站在使用缓存后，使对大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作（缓存访问不命中、缓存过期）和全部的写操作都需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。 目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。网站利用数据库的这一功能，实现数据库读写分离，从而改善数据库负载压力。如下图所示：\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180317/JCH4KbjLFb.webp)\r\n\r\n\r\n\r\n应用服务器在写数据的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库，这样当应用服务器读数据的时候，就可以通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离对应用透明。\r\n\r\n### 使用反向代理和 CDN 加速网站响应\r\n\r\n随着网站业务不断发展，用户规模越来越大，由于中国复杂的网络环境，不同地区的用户访问网站时，速度差别也极大。有研究表明，网站访问延迟和用户流失率正相关，网站访问越慢，用户越容易失去耐心而离开。为了提供更好的用户体验，留住用户，网站需要加速网站访问速度。主要手段有使用 CDN 和方向代理。如下图所示：\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180317/h87G34EGgG.webp)\r\n\r\n\r\n\r\nCDN 和反向代理的基本原理都是缓存。\r\n\r\n> CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据\r\n>\r\n> 反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户\r\n\r\n使用 CDN 和反向代理的目的都是尽早返回数据给用户，一方面加快用户访问速度，另一方面也减轻后端服务器的负载压力。\r\n\r\n### 使用分布式文件系统和分布式数据库系统\r\n\r\n任何强大的单一服务器都满足不了大型网站持续增长的业务需求。数据库经过读写分离后，从一台服务器拆分成两台服务器，但是随着网站业务的发展依然不能满足需求，这时需要使用分布式数据库。文件系统也一样，需要使用分布式文件系统。如下图所示：\r\n\r\n\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180317/1a2khLa5hG.webp)\r\n\r\n\r\n\r\n分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同业务的数据部署在不同的物理服务器上。\r\n\r\n### 使用 NoSQL 和搜索引擎\r\n\r\n随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，网站需要采用一些非关系数据库技术如 NoSQL 和非数据库查询技术如搜索引擎。如下图所示：\r\n\r\n\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180317/6Db1FD48CA.webp)\r\n\r\n\r\n\r\nNoSQL 和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。\r\n\r\n### 业务拆分\r\n\r\n大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将整个网站业务分成不同的产品线。如大型购物交易网站都会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。\r\n\r\n具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署。应用之间可以通过一个超链接建立关系（在首页上的导航链接每个都指向不同的应用地址），也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统，如下图所示：\r\n\r\n\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180317/h997m50jFb.webp)\r\n\r\n### 分布式服务\r\n\r\n随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。\r\n\r\n既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作。如下图所示：\r\n\r\n\r\n\r\n![mark](http://omi0o6pp2.bkt.clouddn.com/blog/180317/LIi8aLlc6e.webp)\r\n\r\n\r\n\r\n大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题也都可以通过组合改进现有技术架构解决。关于分布式的内容，可以继续看分布式系列文章。\r\n\r\n—————END—————', 1, 'post', 'publish', '架构', '默认分类', 30, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (12, '20岁无资本无未来（华文）', NULL, 1526546901, 1527995993, '你学习一般，考上了现在的这所学校，成绩不算好，拿不到奖学金，上课不听讲，上自习不规律，考试靠突击，同学帮一把的话也能每科考到七八十分，但是与优秀总有很大距离。\r\n\r\n你家境一般，父母都是普通员工，你在这个城市的生活费是每月一千二，没事下下馆子，一个月添件衣服，想买台相机，咬咬牙才能买双自己喜欢的鞋。 \r\n\r\n你几乎没有特长，不会弹吉他，不会弹钢琴，不会跳舞，不会画画，想学摄影却不会使用图片处理软件，想上台演出却没信心，学校晚会比赛的时候，你经常是站在台下围观的人群里的一员，你与聚光灯环绕的舞台几乎绝缘。\r\n\r\n你长相一般，不算英俊或者不算美丽，身材不算臃肿但也没什么肌肉或者没什么曲线，平时只是稍稍打扮一下，看上去并不出众，只能算整洁，与人擦肩而过是对方不会多留意你一眼。\r\n\r\n你的感情也是一般，有时候会遇见自己心仪的那个人，但是总抓不住机会，眨眼间那个人就被其他人俘获，你就开始伤心、抱怨，但是几天之后又开始寻找新的心上人，就这样看着一个个心上人走过，直到你毕业，与其中任何一个都没有发展。 总之，你没有什么特别的地方 ，就和周围的千万个普通人一样。 \r\n\r\n你不甘心拿不到奖学金，看见别人得奖学金的时候你会说那完全是突击的结果，于是你开始上自习，不过你只坚持了一星期。 \r\n\r\n你不甘心自己的父辈平平，于是你批评讽刺自己周围的“官二代”、“富二代”，立志要努力学习争取成功，也好让自己的孩子成为“富二代”，你的热情持续了一个星期。 \r\n\r\n\r\n你不甘心自己什么特长都没有，于是你开始学弹吉他、买滑轮鞋、借来摄影方面的书籍，你对着镜子微笑着说：“你是最棒的。” 这份虚假的信心维持了一个星期。 \r\n\r\n你不甘心自己没有伴侣，你决心洗心革面重新做人，你删掉电脑里的偶像剧肥皂剧，你收拾起床上的懒人桌，把零食袋子统统扔掉，然后洗了个澡并且修饰了一下自己，你往发型上喷了啫喱水，好让自己看起来很精神，你怀揣着一本成功学的书决定出去走走，开始新的生活。这样的状态，你稀稀拉拉地坚持了一个星期。\r\n\r\n一个星期之后，你还是和周围千万个人一样，你还是和一星期前的自己一样。 \r\n\r\n你逛网络论坛，看到了这样一句话：“二十岁是人生最美好的时光，不应该局限在学校里教室里，应该享受生活。” 于是你相信了，你觉得二十岁的你就应该“随心所欲”，享受“人生中最后的自由时光”；就应该“快乐地去恋爱”“风华正茂”“挥斥方遒”······ \r\n现在的你，用着父母的血汗钱，用着名牌包、穿着名牌跑鞋、骑着捷安特山地车、用着佳能牌的相机和苹果牌的手机，还经常去星巴克喝喝咖啡体验一下小资情调······ \r\n那么，请允许我猜测一下你的未来—— \r\n\r\n在大四将要结束时，你考研落榜。你风风火火的参加校园招聘会，很多公司你都看不上，嫌他们不是体制内单位、平台窄、规模小，直到毕业，你还没有找到心仪的工作。你收拾好行李回到老家，父母让你试着参加各种招聘考试或者参加当地的应聘会，你不去，因为你觉得那些工作太简单了，不适合你，你应该去寻找更好的就业机会。可是，当你去那些你看得上的公司应聘时，你的竞争对手太多了，而且都不差，你表现平平，理所当然地被拒之门外······ \r\n\r\n现在的你，也许还在上大学，也许和恋人恩恩爱爱，每天黏在一起，午饭晚饭一起去吃，晚自习后还会一起在操场散步。你们讨论起未来，最后的结论总是：不要想得太多，认真过好现在就好。 不幸运的话，几个月后，你们就分手了，你凄凄惨惨戚戚，反复问自己究竟哪里做错了；幸运的话，你们会一直恋爱到毕业，最终，你绝得自己不够优秀没能力去对方所在的城市读研或者工作，所以你们带着不舍和悔恨分手了。\r\n\r\n现实很残酷，至此，你信了。 \r\n\r\n现在的你喜欢刷微博，你会全力支持那些你赞同的观点，你会激励否定那些你反对的观点。你爱憎分明，看起来很有正义感。你觉得血气方刚的年轻人就应该敢于说出自己的心声。你可能从来不会去想一个问题：你的观点，来自哪里？其实，它们绝大部分来自网络，它们已经蚕食了你的判断力。 \r\n\r\n现在，我只想问你一个问题：二十岁的你，有什么资本。\r\n\r\n\r\n你只是千千万万人中微不足道的一个人，少了你，地球还是一样会转。\r\n\r\n我敢打赌，一定很久没人和你说过“吃得苦中苦，方为人上人”这句话了吧？ \r\n\r\n你知道“责任”两个字是怎么写的吗? \r\n\r\n当你谈论飞翔的时候，你是不是忘记了地心引力的存在？ \r\n\r\n现在的你，如果还是放纵着自己的懒惰与幼稚，虚度着光阴，那么，你就虚度去吧。\r\n\r\n反正我已经过了二十岁的年纪，我还有未来，我得直奔向前了，不陪你了。\r\n再见 ', 1, 'post', 'publish', '哲理', '默认分类', 18, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (13, '单例模式的五种方案(原创)', NULL, 1526546934, 1527995781, '## 第一种 懒汉式\r\n\r\n```java\r\n// 单例设计方案1 懒汉式\r\npublic class Singleton01 {\r\n\r\n    private Singleton01() {\r\n    }\r\n\r\n    private static Singleton01 instance;\r\n\r\n    public static Singleton01 getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton01();\r\n        }\r\n        return instance;\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 第二种 线程安全懒汉式\r\n\r\n```java\r\n// 单例设计方案2(线程安全单例)\r\npublic class Singleton02 {\r\n\r\n    private Singleton02() {\r\n    }\r\n\r\n    private static Singleton02 instance;\r\n\r\n    public static synchronized Singleton02 getInstance() {\r\n        if (instance == null) {\r\n            instance = new Singleton02();\r\n        }\r\n        return instance;\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n## 第三种 线程安全+效率的懒汉式\r\n\r\n```java\r\n// 单例设计方案3(线程安全+效率)\r\npublic class Singleton03 {// 大对象\r\n\r\n    private Singleton03() {\r\n    }\r\n\r\n    public static Singleton03 instance;\r\n\r\n    public static Singleton03 getInstance() {\r\n        if (instance == null) {\r\n            synchronized (Singleton03.class) {\r\n                if (instance == null) {\r\n                    instance = new Singleton03();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n## 第四种 饿汉式\r\n\r\n```java\r\n// 单例设计方案四(小对象频繁用) 饿汉式\r\npublic class Singleton04 {\r\n\r\n    private Singleton04(){}\r\n\r\n    /**类加载时创建*/\r\n    private static final Singleton04 instance = new Singleton04();\r\n\r\n    /**此方法中因为没有阻塞问题所以适合频繁访问*/\r\n    public static Singleton04 getInstance() {\r\n        return instance;\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 第五种 延迟加载的饿汉式\r\n\r\n```java\r\n// 单例设计方案五(采用延迟加载策略优化设计方案四)\r\npublic class Singleton05 {\r\n\r\n    private Singleton05(){ }\r\n\r\n    static class Lazy{// 类何时被加载\r\n        public static final Singleton05 instance = new Singleton05();\r\n    }\r\n\r\n    public static Singleton05 getInstance() {\r\n        // 何时需要用时加载\r\n        return Lazy.instance;\r\n    }\r\n    // 请问访问Singleton05类的这个方法时候会加载Lazy吗?\r\n    // public static void display(){}\r\n    // 请问访问Singleton05类的show方法时是否需要加载Lazy?\r\n    // public void show(){}\r\n\r\n}\r\n```\r\n\r\n', 1, 'post', 'publish', '设计模式', '默认分类', 52, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (14, 'Comparable与Comparator的区别', NULL, 1526546954, 1527995969, '**Comparable 是自然排序**\r\n\r\n**Comparator 是定制排序**\r\n\r\n>相同点：\r\n>\r\n>1. 都是用来实现集合中元素的比较、排序的\r\n>2. 都可以使用Collections.sort()方法来对对象集合进行排序\r\n>\r\n>不同点：\r\n>\r\n>1. Comparable位于java.lang包下，而Comparator则位于java.util包下\r\n>2. Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序\r\n\r\n**总结**\r\n\r\n使用Comparable接口来实现对象之间的比较时，可以使这个类型（设为A）实现Comparable接口，并可以使用Collections.sort()方法来对A类型的List进行排序，之后可以通过a1.comparaTo(a2)来比较两个对象；\r\n\r\n当使用Comparator接口来实现对象之间的比较时，只需要创建一个实现Comparator接口的比较器（设为AComparator），并将其传给Collections.sort()方法即可对A类型的List进行排序，之后也可以通过调用比较器AComparator.compare(a1, a2)来比较两个对象。\r\n\r\n可以说**一个是自己完成比较，一个是外部程序实现比较的差别而已**。\r\n\r\n用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。\r\n\r\n比如：你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类（实际上你也不能这么做）去改变它的排序行为，这时候只要（也只有）使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。\r\n\r\n\r\n 两种方式，各有各的特点：使用Comparable方式比较时，我们将比较的规则写入了比较的类型中，其特点是**高内聚**。但如果哪天这个规则需要修改，那么我们必须修改这个类型的源代码。如果使用Comparator方式比较，那么我们不需要修改比较的类，其特点是**易维护**，但需要自定义一个比较器，后续比较规则的修改，仅仅是改这个比较器中的代码即可。\r\n\r\n## Comparable接口\r\n\r\nComparable是java.lang包下的一个接口，该接口里只有一个compareTo()方法：\r\n\r\n```java\r\npackage java.lang;\r\nimport java.util.*;\r\n\r\npublic interface Comparable<T> {\r\n    public int compareTo(T o);\r\n}\r\n```\r\n\r\n\r\nComparable翻译为“可比较的”，表明实现该接口的类都是可以比较的，即实现Comparable接口的类本身就已经支持自比较，例如： String、Integer 自己就可以完成比较大小操作，它们已经实现了Comparable接口。查看String类的源码可以看见是这样声明的（JDK1.7）：\r\n\r\n```java\r\npublic final class String\r\n    implements java.io.Serializable, Comparable<String>, CharSequence\r\n```\r\n\r\n而Integer类的声明如下：\r\n\r\n```java\r\npublic final class Integer extends Number implements Comparable<Integer>\r\n```\r\n\r\n可见它们都实现了Comparable接口，它们的实例都可以通过调用自身的compareTo()方法来比较自己，例如：\r\n\r\n```java\r\nString s1 = \"aa\";\r\nString s2 = \"ab\";\r\nSystem.out.println(s1.compareTo(s2)); //返回是两字符串第一个不同的char的unicode编码的差\r\nInteger i1 = 3;\r\nInteger i2 = 2;\r\nSystem.out.println(i1.compareTo(i2)); //前者大返回1，后者大返回-1，相等返回0\r\n```\r\n\r\n而String类中的compareTo方法时这样实现的：\r\n\r\n```java\r\npublic int compareTo(String anotherString) {\r\n    int len1 = value.length;\r\n    int len2 = anotherString.value.length;\r\n    int lim = Math.min(len1, len2);\r\n    char v1[] = value;\r\n    char v2[] = anotherString.value;\r\n\r\n    int k = 0;\r\n    while (k < lim) {\r\n        char c1 = v1[k];\r\n        char c2 = v2[k];\r\n        if (c1 != c2) {\r\n            return c1 - c2;//返回第一个不同字母的unicode的差\r\n        }\r\n        k++;\r\n    }\r\n    return len1 - len2;//如果两个字符串只有长度不同，则返回长度的差\r\n}\r\n```\r\n\r\nInteger类中的compareTo()方法的实现如下：\r\n\r\n```\r\npublic int compareTo(Integer anotherInteger) {\r\n    return compare(this.value, anotherInteger.value);\r\n}\r\npublic static int compare(int x, int y) {\r\n    return (x < y) ? -1 : ((x == y) ? 0 : 1); //前者大返回1，后者大返回-1，相等返回0\r\n}\r\n```\r\n\r\n因此，我们可以参照String类及Integer类对于Comparable接口的实现来实现自己的比较方式，然后调用compareTo方法即可知道他们的顺序。 下面是一个例子（按Person类的年龄排序）：\r\n\r\n```java\r\nimport java.util.Arrays;\r\n\r\npublic class ComparableTest {\r\n    public static void main(String[] args) {\r\n        Person[] persons = new Person[]{\r\n            new Person(20, \"P1\"),\r\n            new Person(60, \"P2\"),\r\n            new Person(50, \"P3\"),\r\n            new Person(40, \"P4\")\r\n        };\r\n        Arrays.sort(persons);\r\n        System.out.println();\r\n        //下面代码的结果一样\r\n        //List<Person> personList = Arrays.asList(persons);\r\n        //Collections.sort(personList);\r\n        //System.out.println(personList);\r\n    }\r\n}\r\n\r\nclass Person implements Comparable<Person> {\r\n    private int age;\r\n    private String name;\r\n    public Person(int age, String name) {\r\n        this.age = age;\r\n        this.name = name;\r\n    }\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n    public String getName() {\r\n        return name;\r\n    }\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    //实现Comparable接口的compareTo方法\r\n    @Override\r\n    public int compareTo(Person o) {\r\n        return this.age - o.age;\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return \"Person[name=\" + name + \", age=\" + age + \"]\";\r\n    }\r\n}\r\n```\r\n\r\n执行结果是：\r\n\r\n```java\r\n[Person[name=P1, age=20], Person[name=P4, age=40], Person[name=P3, age=50], Person[name=P2, age=60]]\r\n```\r\n\r\n由此可见，Person对象已经通过Arrays.sort()方法按照age排序。\r\n\r\n## 实现Comparator接口\r\n\r\nComparator是java.util包下的一个接口，该接口里有两个方法compare()和equals()：\r\n\r\n```java\r\npackage java.util;\r\n\r\npublic interface Comparator<T> {\r\n    int compare(T o1, T o2);\r\n    boolean equals(Object obj);\r\n}\r\n```\r\n\r\nComparator翻译为“比较器”，表明实现该接口的类都是一个比较器，一般在要比较的对象类型不支持自比较或者自比较函数不能满足要求时使用。使用此接口时，我们可以不在需要比较的类型（这里是Person类）中实现比较过程，而是把这个过程转移到了Comparator接口的compare方法中。于是，上面的例子需要修改为：\r\n\r\n```java\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\n\r\npublic class ComparableTest {\r\n    public static void main(String[] args) {\r\n        Person[] persons = new Person[]{\r\n            new Person(20, \"P1\"),\r\n            new Person(60, \"P2\"),\r\n            new Person(50, \"P3\"),\r\n            new Person(40, \"P4\")\r\n        };\r\n        //Arrays.sort方法不支持使用Comparator比较器了，这里只能使用Collections.sort来排序\r\n        List<Person> personList = Arrays.asList(persons);\r\n        System.out.println(\"Before sort: \\r\\n\" + personList);\r\n        //这里，将一个比较器（Comparator）传递给sort方法作为参数，按照里面的比较逻辑对Person进行排序\r\n        Collections.sort(personList, new PersonComparator());\r\n        System.out.println(\"After sort: \\r\\n\" + personList);\r\n    }\r\n}\r\n\r\n//被比较的类型不需要实现任何接口\r\nclass Person { \r\n    private int age;\r\n    private String name;\r\n    public Person(int age, String name) {\r\n        this.age = age;\r\n        this.name = name;\r\n    }\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n    public String getName() {\r\n        return name;\r\n    }\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Person[name=\" + name + \", age=\" + age + \"]\";\r\n    }\r\n}\r\n\r\n//这是一个比较器，用于比较Person对象\r\nclass PersonComparator implements Comparator<Person> {\r\n    @Override\r\n    public int compare(Person o1, Person o2) {\r\n        //两个Person对象的比较过程，当然，这里可以实现更多更复杂的比较过程\r\n        return o1.getAge() - o2.getAge();   //如果o1.age > o2.age，方法返回正数，为正数正是表明哦o1 > o2\r\n                                            //如果o1.age = o2.age，方法返回0，返回0正是表明o1 == o1\r\n                                            //如果o1.age < o2.age，方法返回正数，为负数正是表明哦o1 < o2\r\n    }\r\n}\r\n```\r\n\r\n 输出结果为：\r\n\r\n```\r\nBefore sort: \r\n[Person[name=P1, age=20], Person[name=P2, age=60], Person[name=P3, age=50], Person[name=P4, age=40]]\r\nAfter sort: \r\n[Person[name=P1, age=20], Person[name=P4, age=40], Person[name=P3, age=50], Person[name=P2, age=60]]\r\n```\r\n\r\n​ 由此可见，我们可以将一个自定义的比较器作为参数传递给Collections.sort()方法，下图是API中的Collections.sort()方法：\r\n\r\n![img](http://static.oschina.net/uploads/space/2014/0412/200740_FAHb_1434710.jpg)\r\n\r\n\r\n\r\nPerson对象已经按照比较器中的规则进行排序。如果在使用Collections.sort()方法时不提供这个Comparator（其实就是使用前文介绍的排序方式），那么就以自然顺序排序，如Collections.sort()方法的API所说：Sorts the specified list into ascending order, according to the natural ordering of its elements. All elements in the list must implement the**Comparable **interface. 这里的自然顺序就是实现Comparable接口设定的排序方式。\r\n\r\n细心的同学已经看到，Comparator接口中还有个equals()方法没有实现，可程序并没有报错，原因是实现该接口的类也是Object类的子类，而Object类已经实现了equals方法。\r\n\r\n> 参考链接 [Comparable与Comparator的区别](https://my.oschina.net/itblog/blog/221468)  ', 1, 'post', 'publish', 'java', '默认分类', 60, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (15, 'Java中遍历Map的几种方式', NULL, 1526546967, 1527995695, '> 参考资料 [Java中如何遍历Map对象的4种方法 - CSDN博客](https://blog.csdn.net/tjcyjd/article/details/11111401)\r\n\r\n> 自己的总结\r\n>\r\n> 1. 在for-each循环中遍历entrySet    		\r\n> 2. 在for-each循环中遍历keySet或values\r\n> 3. 使用Iterator遍历\r\n> 4. 先获取keySet再根据key获取value\r\n>\r\n> 效率比较：\r\n>\r\n> 1和3效率类同\r\n>\r\n> 2比1效率快10%\r\n>\r\n> 4比1慢了20%~200% 不建议使用\r\n\r\n\r\n\r\n## 方法一 在for-each循环中使用entries来遍历\r\n\r\n这是最常见的并且在大多数情况下也是最可取的遍历方式。在键值都需要时使用。\r\n\r\n```java\r\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \r\n  \r\nfor (Map.Entry<Integer, Integer> entry : map.entrySet()) {  \r\n  \r\n    System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue()); \r\n  \r\n}  \r\n```\r\n\r\n注意：for-each循环在java 5中被引入所以该方法只能应用于java 5或更高的版本中。如果你遍历的是一个空的map对象，for-each循环将抛出NullPointerException，因此在遍历前你总是应该检查空引用。\r\n\r\n\r\n## 方法二 在for-each循环中遍历keys或values。\r\n\r\n如果只需要map中的键或者值，你可以通过keySet或values来实现遍历，而不是用entrySet。\r\n\r\n```java\r\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \r\n  \r\n//遍历map中的键  \r\n  \r\nfor (Integer key : map.keySet()) {  \r\n  \r\n    System.out.println(\"Key = \" + key);  \r\n  \r\n}  \r\n  \r\n//遍历map中的值  \r\n  \r\nfor (Integer value : map.values()) {  \r\n  \r\n    System.out.println(\"Value = \" + value);  \r\n  \r\n}  \r\n```\r\n\r\n该方法比entrySet遍历在性能上稍好（快了10%），而且代码更加干净。\r\n\r\n## 方法三使用Iterator遍历\r\n\r\n**使用泛型：**\r\n\r\n```java\r\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \r\n  \r\nIterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator();  \r\n  \r\nwhile (entries.hasNext()) {  \r\n  \r\n    Map.Entry<Integer, Integer> entry = entries.next();  \r\n  \r\n    System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue());  \r\n  \r\n}  \r\n```\r\n\r\n**不使用泛型：**\r\n\r\n```java\r\nMap map = new HashMap();  \r\n  \r\nIterator entries = map.entrySet().iterator();  \r\n  \r\nwhile (entries.hasNext()) {  \r\n  \r\n    Map.Entry entry = (Map.Entry) entries.next();  \r\n  \r\n    Integer key = (Integer)entry.getKey();  \r\n  \r\n    Integer value = (Integer)entry.getValue();  \r\n  \r\n    System.out.println(\"Key = \" + key + \", Value = \" + value);  \r\n  \r\n}  \r\n```\r\n\r\n你也可以在keySet和values上应用同样的方法。\r\n\r\n该种方式看起来冗余却有其优点所在。首先，在老版本java中这是惟一遍历map的方式。另一个好处是，你可以在遍历时调用iterator.remove()来删除entries，另两个方法则不能。根据javadoc的说明，如果在for-each遍历中尝试使用此方法，结果是不可预测的。\r\n\r\n从性能方面看，该方法类同于for-each遍历（即方法二）的性能。\r\n\r\n## 方法四、通过键找值遍历（效率低）\r\n\r\n```java\r\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \r\n  \r\nfor (Integer key : map.keySet()) {  \r\n  \r\n    Integer value = map.get(key);  \r\n  \r\n    System.out.println(\"Key = \" + key + \", Value = \" + value);  \r\n  \r\n}  \r\n```\r\n\r\n作为方法一的替代，这个代码看上去更加干净；但实际上它相当慢且无效率。因为从键取值是耗时的操作（与方法一相比，在不同的Map实现中该方法慢了20%~200%）。如果你安装了FindBugs，它会做出检查并警告你关于哪些是低效率的遍历。所以尽量避免使用。\r\n\r\n## 总结\r\n\r\n如果仅需要键(keys)或值(values)使用方法二。如果你使用的语言版本低于java 5，或是打算在遍历时删除entries，必须使用方法三。否则使用方法一(键值都要)。\r\n', 1, 'post', 'publish', '集合', 'Java', 101, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (16, '深入分析Java中的length和length()', NULL, 1527516824, 1528105939, '在开始正文之前，请你快速回答如下问题：\r\n\r\n> 在不使用任何带有自动补全功能IDE的情况下，如何获取一个数组的长度？以及，如何获取一个字符串的长度？\r\n\r\n这个问题我问过不同水平的程序员，包括初级和中级水平的。他们都不能准确而自信地回答这个问题（如果你能很准确很自信的回答这个问题，那么证明针对这一知识点你比大多数中级程序员掌握的好）。由于现在很多IDE都有代码补全功能，这使得开发人员在很多问题上都理解的很肤浅。本文将介绍几个关于Java数组的关键概念。\r\n\r\n上面问题的正确回答姿势应该是这样的：\r\n\r\n```java\r\nint[] arr = new int[3]; //使用length获取数组的程序\r\nSystem.out.println(arr.length);\r\n\r\nString str = \"abc\";\r\nSystem.out.println(str.length());//使用length()获取字符串的长度\r\n```\r\n\r\n那么问题来了，为什么数组有`length`属性，而字符串没有？或者，为什么字符串有`length()`方法，而数组没有？\r\n\r\n# 为什么数组有length属性？\r\n\r\n首先，数组是一个容器对象，其中包含固定数量的同一类型的值。一旦数组被创建，他的长度就是固定的了。数组的长度可以作为`final`实例变量的长度。因此，长度可以被视为一个数组的属性。\r\n\r\n有两种创建数组的方法：\r\n\r\n1、通过数组表达式创建数组。\r\n\r\n2、通过初始化值创建数组。\r\n\r\n\r\n无论使用哪种方式，一旦数组被创建，其大小就固定了\r\n\r\n使用表达式创建数组方式如下，该方式指明了元素类型、数组的维度、以及至少一个维度的数组的长度。\r\n\r\n```java\r\nint[][] arr = new int[3][];\r\n```\r\n\r\n该声明方式是符合要求的，因为他指定了一个维度的长度（该数组的类型为int，维度为2，第一维度的长度为3）\r\n\r\n使用数组初始化的方式创建数组时需要提供所有的初始值。形式是使用`{`和`}`将所有初始值括在一起并用`,`隔开。\r\n\r\n```java\r\nint[] arr = {1,2,3};\r\n```\r\n\r\n注：\r\n\r\n这里可能会有一个疑问，既然数组大小是初始化时就规定好的，那么`int[][] arr = new int[3][];`定义的数组并没有给出数组的第二维的大小，那么这个`arr`的长度到底是如何“规定好”的呢？\r\n\r\n其实，`arr`的长度就是3。其实Java中所有的数组，无论几维，其实都是一维数组。例如arr，分配了3个空间，每个空间存放一个一维数组的地址，这样就成了“二维”数组。但是对于arr来说，他的长度就是3。\r\n\r\n```java\r\nint[] arr = new int[3]; \r\nSystem.out.println(arr.length);//3\r\nint[][] b = new int[3][5];\r\nSystem.out.println(b.length);//3\r\n```\r\n# Java中为什么没有定义一个类似String一样Array类\r\n\r\n因为数组也是对象，所以下面的代码也是合法的：\r\n\r\n```\r\nObject obj = new int[10];\r\n```\r\n\r\n数组包含所有从Object继承下来方法，除clone()之外。为什么没有一个Array类呢？在Java中没有`Array.java`文件。一个简单的解释是它被隐藏起来了（注：Java中的数组有点类似于基本数据类型，是一个内建类型，并没有实际的类与他对应）。\r\n\r\n你可以思考这样一个问题——如果有一个Array类，那它会像什么样？它会仍然需要一个数组来存放所有的数组元素，对吗？因此，定义出一个Array类不是一个好的主意。（注：这里可能有点绕，道理有点类似于：鸡生蛋蛋生鸡问题，可能比喻也不是很恰当，请读者自行理解）\r\n\r\n事实上我们可以获得数组的类定义，通过下面的代码：\r\n\r\n```java\r\nint[] arr = new int[3]; \r\nSystem.out.println(arr.getClass());\r\n```\r\n\r\n输出：\r\n\r\n```java\r\nclass [I\r\n```\r\n\r\n“class [I”代表着”成员类型是int的数组”的class对象运行时类型的签名\r\n\r\n# 为什么String有length()方法？\r\n\r\nString背后的数据结构是一个char数组,所以没有必要来定义一个不必要的属性（因为该属性在char数值中已经提供了）。和C不同的是，Java中char的数组并不等于字符串，虽然String的内部机制是char数组实现的。（注：C语言中，并没有String类，定义字符串通常使用`char string[6] = \"hollis\";`的形式）\r\n\r\n```java\r\nchar [] s = {\'a\',\'b\',\'c\'};\r\nString string1 = s.toString();\r\nString string2 = new String(s);\r\nString string3 = String.valueOf(s);\r\n```\r\n\r\n', 1, 'post', 'publish', 'java基础,java', 'Java', 166, 0, 1, 1, 1);
INSERT INTO `t_contents` VALUES (17, '55', NULL, 1528216166, 1528216596, 'FFfff\r\n\r\n[请输入链接描述][1]\r\n\r\n\r\n  [1]: http://localhost:8081/upload/2018/05/uhife2m61mipvqqv8pl1h5gi88.rar', 1, 'post', 'publish', '', '默认分类', 12, 0, 1, 1, 1);

-- ----------------------------
-- Table structure for t_logs
-- ----------------------------
DROP TABLE IF EXISTS `t_logs`;
CREATE TABLE `t_logs`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '日志主键',
  `action` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '产生的动作',
  `data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '产生的数据',
  `author_id` int(10) DEFAULT NULL COMMENT '发生人id',
  `ip` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '日志产生的ip',
  `created` int(10) DEFAULT NULL COMMENT '日志创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 171 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '日志表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_logs
-- ----------------------------
INSERT INTO `t_logs` VALUES (1, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815277);
INSERT INTO `t_logs` VALUES (2, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815280);
INSERT INTO `t_logs` VALUES (3, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815318);
INSERT INTO `t_logs` VALUES (4, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815398);
INSERT INTO `t_logs` VALUES (5, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815482);
INSERT INTO `t_logs` VALUES (6, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496815492);
INSERT INTO `t_logs` VALUES (7, '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"Blog\",\"site_theme\":\"default\",\"allow_install\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1496815955);
INSERT INTO `t_logs` VALUES (8, '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"Blog\",\"site_theme\":\"default\",\"allow_install\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1496815964);
INSERT INTO `t_logs` VALUES (9, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496989015);
INSERT INTO `t_logs` VALUES (10, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1496989366);
INSERT INTO `t_logs` VALUES (11, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497317863);
INSERT INTO `t_logs` VALUES (12, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/tian-zhisheng/activities\",\"social_github\":\"https://github.com/zhisheng17\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1497318696);
INSERT INTO `t_logs` VALUES (13, '修改个人信息', '{\"uid\":1,\"email\":\"1041218129@qq.com\",\"screenName\":\"admin\"}', 1, '0:0:0:0:0:0:0:1', 1497319220);
INSERT INTO `t_logs` VALUES (14, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497319856);
INSERT INTO `t_logs` VALUES (15, '登录后台', NULL, 1, '127.0.0.1', 1497321561);
INSERT INTO `t_logs` VALUES (16, '登录后台', NULL, 1, '127.0.0.1', 1497322738);
INSERT INTO `t_logs` VALUES (17, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497323446);
INSERT INTO `t_logs` VALUES (18, '删除文章', '2', 1, '0:0:0:0:0:0:0:1', 1497323495);
INSERT INTO `t_logs` VALUES (19, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497427641);
INSERT INTO `t_logs` VALUES (20, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497428250);
INSERT INTO `t_logs` VALUES (21, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497428290);
INSERT INTO `t_logs` VALUES (22, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497428556);
INSERT INTO `t_logs` VALUES (23, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497674581);
INSERT INTO `t_logs` VALUES (24, '修改个人信息', '{\"uid\":1,\"email\":\"1041218129@qq.com\",\"screenName\":\"admin\"}', 1, '0:0:0:0:0:0:0:1', 1497674690);
INSERT INTO `t_logs` VALUES (25, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497676623);
INSERT INTO `t_logs` VALUES (26, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497683817);
INSERT INTO `t_logs` VALUES (27, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1497685128);
INSERT INTO `t_logs` VALUES (28, '登录后台', NULL, 1, '127.0.0.1', 1497689032);
INSERT INTO `t_logs` VALUES (29, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1523966148);
INSERT INTO `t_logs` VALUES (30, '删除文章', '7', 1, '0:0:0:0:0:0:0:1', 1523966397);
INSERT INTO `t_logs` VALUES (31, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1523967300);
INSERT INTO `t_logs` VALUES (32, '删除文章', '/upload/2017/06/t93vgdj6o8irgo87ds56u0ou0s.jpeg', 1, '0:0:0:0:0:0:0:1', 1523967355);
INSERT INTO `t_logs` VALUES (33, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1523967544);
INSERT INTO `t_logs` VALUES (34, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1523967651);
INSERT INTO `t_logs` VALUES (35, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1523967852);
INSERT INTO `t_logs` VALUES (36, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1523968076);
INSERT INTO `t_logs` VALUES (37, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1523968258);
INSERT INTO `t_logs` VALUES (38, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525259810);
INSERT INTO `t_logs` VALUES (39, '登录后台', NULL, 1, '127.0.0.1', 1525333815);
INSERT INTO `t_logs` VALUES (40, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525338119);
INSERT INTO `t_logs` VALUES (41, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525397892);
INSERT INTO `t_logs` VALUES (42, '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"Blog\",\"site_theme\":\"default\",\"allow_install\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525399977);
INSERT INTO `t_logs` VALUES (43, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525430089);
INSERT INTO `t_logs` VALUES (44, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525657922);
INSERT INTO `t_logs` VALUES (45, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525657923);
INSERT INTO `t_logs` VALUES (46, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525660818);
INSERT INTO `t_logs` VALUES (47, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525686803);
INSERT INTO `t_logs` VALUES (48, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525687123);
INSERT INTO `t_logs` VALUES (49, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525687228);
INSERT INTO `t_logs` VALUES (50, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525687534);
INSERT INTO `t_logs` VALUES (51, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525687536);
INSERT INTO `t_logs` VALUES (52, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525688087);
INSERT INTO `t_logs` VALUES (53, '修改个人信息', '{\"uid\":1,\"email\":\"1341947277@qq.com\",\"screenName\":\"admin\"}', 1, '0:0:0:0:0:0:0:1', 1525688099);
INSERT INTO `t_logs` VALUES (54, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525688809);
INSERT INTO `t_logs` VALUES (55, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525765611);
INSERT INTO `t_logs` VALUES (56, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/tian-zhisheng/activities\",\"social_github\":\"https://github.com/zhisheng17\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525765632);
INSERT INTO `t_logs` VALUES (57, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525765827);
INSERT INTO `t_logs` VALUES (58, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525765827);
INSERT INTO `t_logs` VALUES (59, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525765827);
INSERT INTO `t_logs` VALUES (60, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/tian-zhisheng/activities\",\"social_github\":\"https://github.com/zhisheng17\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525766002);
INSERT INTO `t_logs` VALUES (61, '保存系统设置', '{\"site_record\":\"\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"Blog\",\"site_theme\":\"default\",\"allow_install\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525766068);
INSERT INTO `t_logs` VALUES (62, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525766230);
INSERT INTO `t_logs` VALUES (63, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525766315);
INSERT INTO `t_logs` VALUES (64, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/tian-zhisheng/activities\",\"social_github\":\"https://github.com/gaohanghang\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525766320);
INSERT INTO `t_logs` VALUES (65, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525766330);
INSERT INTO `t_logs` VALUES (66, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525766433);
INSERT INTO `t_logs` VALUES (67, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/gao-xing-68-15/activities\",\"social_github\":\"https://github.com/gaohanghang\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525766453);
INSERT INTO `t_logs` VALUES (68, '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"高行行的个人博客\",\"site_theme\":\"default\",\"allow_install\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525766477);
INSERT INTO `t_logs` VALUES (69, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525766877);
INSERT INTO `t_logs` VALUES (70, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525767546);
INSERT INTO `t_logs` VALUES (71, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525779549);
INSERT INTO `t_logs` VALUES (72, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525780017);
INSERT INTO `t_logs` VALUES (73, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/gao-xing-68-15/activities\",\"social_github\":\"https://github.com/gaohanghang\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525780021);
INSERT INTO `t_logs` VALUES (74, '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"高行行的个人博客\",\"site_theme\":\"default\",\"allow_install\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525780403);
INSERT INTO `t_logs` VALUES (75, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/gao-xing-68-15/activities\",\"social_github\":\"https://github.com/gaohanghang\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525780405);
INSERT INTO `t_logs` VALUES (76, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525782355);
INSERT INTO `t_logs` VALUES (77, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/gao-xing-68-15/activities\",\"social_github\":\"https://github.com/gaohanghang\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525782360);
INSERT INTO `t_logs` VALUES (78, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1525852469);
INSERT INTO `t_logs` VALUES (79, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/gao-xing-68-15/activities\",\"social_github\":\"https://github.com/gaohanghang\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1525852487);
INSERT INTO `t_logs` VALUES (80, '修改个人信息', '{\"uid\":1,\"email\":\"1341947277@qq.com\",\"screenName\":\"admin\"}', 1, '0:0:0:0:0:0:0:1', 1525852901);
INSERT INTO `t_logs` VALUES (81, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526542926);
INSERT INTO `t_logs` VALUES (82, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526543142);
INSERT INTO `t_logs` VALUES (83, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526543412);
INSERT INTO `t_logs` VALUES (84, '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"高行行的个人博客\",\"site_theme\":\"default\",\"allow_install\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1526545583);
INSERT INTO `t_logs` VALUES (85, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526546248);
INSERT INTO `t_logs` VALUES (86, '修改个人信息', '{\"uid\":1,\"email\":\"1341947277@qq.com\",\"screenName\":\"高行行\"}', 1, '0:0:0:0:0:0:0:1', 1526546421);
INSERT INTO `t_logs` VALUES (87, '保存系统设置', '{\"site_keywords\":\"Blog\",\"site_description\":\"SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统\",\"site_title\":\"高行行的个人博客\",\"site_theme\":\"default\",\"allow_install\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1526548676);
INSERT INTO `t_logs` VALUES (88, '系统备份', NULL, 1, '0:0:0:0:0:0:0:1', 1526548719);
INSERT INTO `t_logs` VALUES (89, '系统备份', NULL, 1, '0:0:0:0:0:0:0:1', 1526548754);
INSERT INTO `t_logs` VALUES (90, '删除文章', '/upload/2018/05/rk8k7tqpogju9pd3j3qc5s0d8b.sql', 1, '0:0:0:0:0:0:0:1', 1526548842);
INSERT INTO `t_logs` VALUES (91, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526613962);
INSERT INTO `t_logs` VALUES (92, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526614718);
INSERT INTO `t_logs` VALUES (93, '系统备份', NULL, 1, '0:0:0:0:0:0:0:1', 1526614754);
INSERT INTO `t_logs` VALUES (94, '系统备份', NULL, 1, '0:0:0:0:0:0:0:1', 1526614756);
INSERT INTO `t_logs` VALUES (95, '系统备份', NULL, 1, '0:0:0:0:0:0:0:1', 1526614773);
INSERT INTO `t_logs` VALUES (96, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526620144);
INSERT INTO `t_logs` VALUES (97, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526620145);
INSERT INTO `t_logs` VALUES (98, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526620562);
INSERT INTO `t_logs` VALUES (99, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526623749);
INSERT INTO `t_logs` VALUES (100, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526627721);
INSERT INTO `t_logs` VALUES (101, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1526630836);
INSERT INTO `t_logs` VALUES (102, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527083956);
INSERT INTO `t_logs` VALUES (103, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527083956);
INSERT INTO `t_logs` VALUES (104, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527166398);
INSERT INTO `t_logs` VALUES (105, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527515337);
INSERT INTO `t_logs` VALUES (106, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/gao-xing-68-15/activities\",\"social_github\":\"https://github.com/gaohanghang\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1527516422);
INSERT INTO `t_logs` VALUES (107, '登录后台', NULL, 1, '127.0.0.1', 1527519697);
INSERT INTO `t_logs` VALUES (108, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527519737);
INSERT INTO `t_logs` VALUES (109, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527553546);
INSERT INTO `t_logs` VALUES (110, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527558300);
INSERT INTO `t_logs` VALUES (111, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527559731);
INSERT INTO `t_logs` VALUES (112, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527580971);
INSERT INTO `t_logs` VALUES (113, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527602023);
INSERT INTO `t_logs` VALUES (114, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527605365);
INSERT INTO `t_logs` VALUES (115, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527609271);
INSERT INTO `t_logs` VALUES (116, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527635482);
INSERT INTO `t_logs` VALUES (117, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527641835);
INSERT INTO `t_logs` VALUES (118, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527686574);
INSERT INTO `t_logs` VALUES (119, '系统备份', NULL, 1, '0:0:0:0:0:0:0:1', 1527690179);
INSERT INTO `t_logs` VALUES (120, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527694761);
INSERT INTO `t_logs` VALUES (121, '删除文章', '/upload/2018/05/vamavrug1ihfkp87tr018lulme.jpg', 1, '0:0:0:0:0:0:0:1', 1527694919);
INSERT INTO `t_logs` VALUES (122, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527920648);
INSERT INTO `t_logs` VALUES (123, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527924471);
INSERT INTO `t_logs` VALUES (124, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527924498);
INSERT INTO `t_logs` VALUES (125, '保存系统设置', '{\"social_zhihu\":\"https://www.zhihu.com/people/gao-xing-68-15/activities\",\"social_github\":\"https://github.com/gaohanghang\",\"social_twitter\":\"\",\"social_weibo\":\"\"}', 1, '0:0:0:0:0:0:0:1', 1527924764);
INSERT INTO `t_logs` VALUES (126, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527928257);
INSERT INTO `t_logs` VALUES (127, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527937841);
INSERT INTO `t_logs` VALUES (128, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527937842);
INSERT INTO `t_logs` VALUES (129, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527993750);
INSERT INTO `t_logs` VALUES (130, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1527996751);
INSERT INTO `t_logs` VALUES (131, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528011136);
INSERT INTO `t_logs` VALUES (132, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528012467);
INSERT INTO `t_logs` VALUES (133, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528019146);
INSERT INTO `t_logs` VALUES (134, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528019878);
INSERT INTO `t_logs` VALUES (135, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528019882);
INSERT INTO `t_logs` VALUES (136, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528020023);
INSERT INTO `t_logs` VALUES (137, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528020088);
INSERT INTO `t_logs` VALUES (138, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528027207);
INSERT INTO `t_logs` VALUES (139, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528030372);
INSERT INTO `t_logs` VALUES (140, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528037472);
INSERT INTO `t_logs` VALUES (141, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528072445);
INSERT INTO `t_logs` VALUES (142, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528077659);
INSERT INTO `t_logs` VALUES (143, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528078858);
INSERT INTO `t_logs` VALUES (144, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528096613);
INSERT INTO `t_logs` VALUES (145, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528097544);
INSERT INTO `t_logs` VALUES (146, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528098171);
INSERT INTO `t_logs` VALUES (147, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528098215);
INSERT INTO `t_logs` VALUES (148, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528098216);
INSERT INTO `t_logs` VALUES (149, '登录后台', NULL, 1, '127.0.0.1', 1528098417);
INSERT INTO `t_logs` VALUES (150, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528105919);
INSERT INTO `t_logs` VALUES (151, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528118773);
INSERT INTO `t_logs` VALUES (152, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528159980);
INSERT INTO `t_logs` VALUES (153, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528159989);
INSERT INTO `t_logs` VALUES (154, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528161070);
INSERT INTO `t_logs` VALUES (155, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528163645);
INSERT INTO `t_logs` VALUES (156, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528167478);
INSERT INTO `t_logs` VALUES (157, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528172640);
INSERT INTO `t_logs` VALUES (158, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528178013);
INSERT INTO `t_logs` VALUES (159, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528178013);
INSERT INTO `t_logs` VALUES (160, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528201940);
INSERT INTO `t_logs` VALUES (161, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528208596);
INSERT INTO `t_logs` VALUES (162, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528213846);
INSERT INTO `t_logs` VALUES (163, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528215086);
INSERT INTO `t_logs` VALUES (164, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528247032);
INSERT INTO `t_logs` VALUES (165, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528248548);
INSERT INTO `t_logs` VALUES (166, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528248601);
INSERT INTO `t_logs` VALUES (167, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528248876);
INSERT INTO `t_logs` VALUES (168, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528251413);
INSERT INTO `t_logs` VALUES (169, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528253287);
INSERT INTO `t_logs` VALUES (170, '登录后台', NULL, 1, '0:0:0:0:0:0:0:1', 1528253478);

-- ----------------------------
-- Table structure for t_metas
-- ----------------------------
DROP TABLE IF EXISTS `t_metas`;
CREATE TABLE `t_metas`  (
  `mid` int(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '项目主键',
  `name` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '名称',
  `slug` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '项目缩略名',
  `type` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '项目类型',
  `description` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '选项描述',
  `sort` int(10) UNSIGNED DEFAULT 0 COMMENT '项目排序',
  `parent` int(10) UNSIGNED DEFAULT 0 COMMENT '父级项目',
  PRIMARY KEY (`mid`) USING BTREE,
  INDEX `slug`(`slug`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 44 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '分类/标签表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_metas
-- ----------------------------
INSERT INTO `t_metas` VALUES (6, 'my github', 'https://github.com/gaohanghang', 'link', '', 1, 0);
INSERT INTO `t_metas` VALUES (7, 'my website', 'http://ghang.top', 'link', '', 0, 0);
INSERT INTO `t_metas` VALUES (9, 'Java', 'Java', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (10, 'Java', 'Java', 'category', '有关Java的博客', 0, 0);
INSERT INTO `t_metas` VALUES (20, '随笔', NULL, 'category', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (21, '默认分类', '默认分类', 'category', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (24, 'java学习', 'java学习', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (25, '版本控制', NULL, 'category', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (27, 'Hexo', NULL, 'category', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (28, '数据结构与算法', NULL, 'category', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (29, '关系型数据库', NULL, 'category', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (30, 'Web服务器', NULL, 'category', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (31, 'Linux', NULL, 'category', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (32, 'java基础', 'java基础', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (33, '设计模式', '设计模式', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (34, '集合', '集合', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (35, '文学', NULL, 'category', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (36, '架构', '架构', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (37, 'mysql', 'mysql', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (38, '音乐', '音乐', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (39, 'Java垃圾回收', 'Java垃圾回收', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (40, 'TCP/IP', 'TCP/IP', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (41, 'Mybatis', 'Mybatis', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (42, '哲理', '哲理', 'tag', NULL, 0, 0);
INSERT INTO `t_metas` VALUES (43, '程序喵', 'http://www.ibloger.net/', 'link', '', 2, 0);

-- ----------------------------
-- Table structure for t_options
-- ----------------------------
DROP TABLE IF EXISTS `t_options`;
CREATE TABLE `t_options`  (
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '配置名称',
  `value` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT '' COMMENT '配置值',
  `description` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`name`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '选项表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_options
-- ----------------------------
INSERT INTO `t_options` VALUES ('allow_install', '', '');
INSERT INTO `t_options` VALUES ('site_description', 'SpringBoot+Mybatis+thymeleaf 搭建的 Java 博客系统', NULL);
INSERT INTO `t_options` VALUES ('site_keywords', 'Blog', NULL);
INSERT INTO `t_options` VALUES ('site_record', '', NULL);
INSERT INTO `t_options` VALUES ('site_theme', 'default', NULL);
INSERT INTO `t_options` VALUES ('site_title', '高行行的个人博客', '');
INSERT INTO `t_options` VALUES ('social_github', 'https://github.com/gaohanghang', NULL);
INSERT INTO `t_options` VALUES ('social_twitter', '', NULL);
INSERT INTO `t_options` VALUES ('social_weibo', '', NULL);
INSERT INTO `t_options` VALUES ('social_zhihu', 'https://www.zhihu.com/people/gao-xing-68-15/activities', NULL);

-- ----------------------------
-- Table structure for t_relationships
-- ----------------------------
DROP TABLE IF EXISTS `t_relationships`;
CREATE TABLE `t_relationships`  (
  `cid` int(10) UNSIGNED NOT NULL DEFAULT 0 COMMENT '内容主键',
  `mid` int(10) UNSIGNED NOT NULL DEFAULT 0 COMMENT '项目主键',
  PRIMARY KEY (`cid`, `mid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '文章和分类/标签关系表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_relationships
-- ----------------------------
INSERT INTO `t_relationships` VALUES (3, 21);
INSERT INTO `t_relationships` VALUES (4, 10);
INSERT INTO `t_relationships` VALUES (4, 41);
INSERT INTO `t_relationships` VALUES (5, 21);
INSERT INTO `t_relationships` VALUES (5, 40);
INSERT INTO `t_relationships` VALUES (6, 10);
INSERT INTO `t_relationships` VALUES (6, 39);
INSERT INTO `t_relationships` VALUES (7, 10);
INSERT INTO `t_relationships` VALUES (7, 42);
INSERT INTO `t_relationships` VALUES (8, 21);
INSERT INTO `t_relationships` VALUES (8, 38);
INSERT INTO `t_relationships` VALUES (9, 10);
INSERT INTO `t_relationships` VALUES (9, 21);
INSERT INTO `t_relationships` VALUES (9, 24);
INSERT INTO `t_relationships` VALUES (10, 30);
INSERT INTO `t_relationships` VALUES (10, 37);
INSERT INTO `t_relationships` VALUES (11, 21);
INSERT INTO `t_relationships` VALUES (11, 36);
INSERT INTO `t_relationships` VALUES (12, 21);
INSERT INTO `t_relationships` VALUES (12, 42);
INSERT INTO `t_relationships` VALUES (13, 21);
INSERT INTO `t_relationships` VALUES (13, 33);
INSERT INTO `t_relationships` VALUES (14, 9);
INSERT INTO `t_relationships` VALUES (14, 21);
INSERT INTO `t_relationships` VALUES (15, 10);
INSERT INTO `t_relationships` VALUES (15, 34);
INSERT INTO `t_relationships` VALUES (16, 9);
INSERT INTO `t_relationships` VALUES (16, 10);
INSERT INTO `t_relationships` VALUES (16, 32);
INSERT INTO `t_relationships` VALUES (17, 21);

-- ----------------------------
-- Table structure for t_users
-- ----------------------------
DROP TABLE IF EXISTS `t_users`;
CREATE TABLE `t_users`  (
  `uid` int(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `username` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '用户名',
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '密码',
  `email` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '邮箱',
  `home_url` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '用户url链接',
  `screen_name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `created` int(10) UNSIGNED DEFAULT 0,
  `activated` int(10) UNSIGNED DEFAULT 0,
  `logged` int(10) UNSIGNED DEFAULT 0,
  `group_name` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT 'visitor',
  PRIMARY KEY (`uid`) USING BTREE,
  UNIQUE INDEX `name`(`username`) USING BTREE,
  UNIQUE INDEX `mail`(`email`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_users
-- ----------------------------
INSERT INTO `t_users` VALUES (1, 'admin', 'a66abb5684c45962d887564f08346e8d', '1341947277@qq.com', NULL, '高行行', 1490756162, 0, 0, 'visitor');

SET FOREIGN_KEY_CHECKS = 1;
